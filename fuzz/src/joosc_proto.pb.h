// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: joosc_proto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_joosc_5fproto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_joosc_5fproto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_joosc_5fproto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_joosc_5fproto_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_joosc_5fproto_2eproto;
namespace joosc_fuzzer {
class AssignmentStatement;
struct AssignmentStatementDefaultTypeInternal;
extern AssignmentStatementDefaultTypeInternal _AssignmentStatement_default_instance_;
class BinaryOp;
struct BinaryOpDefaultTypeInternal;
extern BinaryOpDefaultTypeInternal _BinaryOp_default_instance_;
class BoolRvalue;
struct BoolRvalueDefaultTypeInternal;
extern BoolRvalueDefaultTypeInternal _BoolRvalue_default_instance_;
class BoolToBoolOp;
struct BoolToBoolOpDefaultTypeInternal;
extern BoolToBoolOpDefaultTypeInternal _BoolToBoolOp_default_instance_;
class Class;
struct ClassDefaultTypeInternal;
extern ClassDefaultTypeInternal _Class_default_instance_;
class Const;
struct ConstDefaultTypeInternal;
extern ConstDefaultTypeInternal _Const_default_instance_;
class FunctionRef;
struct FunctionRefDefaultTypeInternal;
extern FunctionRefDefaultTypeInternal _FunctionRef_default_instance_;
class IfElse;
struct IfElseDefaultTypeInternal;
extern IfElseDefaultTypeInternal _IfElse_default_instance_;
class IfThen;
struct IfThenDefaultTypeInternal;
extern IfThenDefaultTypeInternal _IfThen_default_instance_;
class IntToBoolOp;
struct IntToBoolOpDefaultTypeInternal;
extern IntToBoolOpDefaultTypeInternal _IntToBoolOp_default_instance_;
class Lvalue;
struct LvalueDefaultTypeInternal;
extern LvalueDefaultTypeInternal _Lvalue_default_instance_;
class MethodInvocation;
struct MethodInvocationDefaultTypeInternal;
extern MethodInvocationDefaultTypeInternal _MethodInvocation_default_instance_;
class MethodInvocationStatement;
struct MethodInvocationStatementDefaultTypeInternal;
extern MethodInvocationStatementDefaultTypeInternal _MethodInvocationStatement_default_instance_;
class Rvalue;
struct RvalueDefaultTypeInternal;
extern RvalueDefaultTypeInternal _Rvalue_default_instance_;
class Statement;
struct StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class StatementSeq;
struct StatementSeqDefaultTypeInternal;
extern StatementSeqDefaultTypeInternal _StatementSeq_default_instance_;
class StaticField;
struct StaticFieldDefaultTypeInternal;
extern StaticFieldDefaultTypeInternal _StaticField_default_instance_;
class VarRef;
struct VarRefDefaultTypeInternal;
extern VarRefDefaultTypeInternal _VarRef_default_instance_;
class While;
struct WhileDefaultTypeInternal;
extern WhileDefaultTypeInternal _While_default_instance_;
}  // namespace joosc_fuzzer
PROTOBUF_NAMESPACE_OPEN
template<> ::joosc_fuzzer::AssignmentStatement* Arena::CreateMaybeMessage<::joosc_fuzzer::AssignmentStatement>(Arena*);
template<> ::joosc_fuzzer::BinaryOp* Arena::CreateMaybeMessage<::joosc_fuzzer::BinaryOp>(Arena*);
template<> ::joosc_fuzzer::BoolRvalue* Arena::CreateMaybeMessage<::joosc_fuzzer::BoolRvalue>(Arena*);
template<> ::joosc_fuzzer::BoolToBoolOp* Arena::CreateMaybeMessage<::joosc_fuzzer::BoolToBoolOp>(Arena*);
template<> ::joosc_fuzzer::Class* Arena::CreateMaybeMessage<::joosc_fuzzer::Class>(Arena*);
template<> ::joosc_fuzzer::Const* Arena::CreateMaybeMessage<::joosc_fuzzer::Const>(Arena*);
template<> ::joosc_fuzzer::FunctionRef* Arena::CreateMaybeMessage<::joosc_fuzzer::FunctionRef>(Arena*);
template<> ::joosc_fuzzer::IfElse* Arena::CreateMaybeMessage<::joosc_fuzzer::IfElse>(Arena*);
template<> ::joosc_fuzzer::IfThen* Arena::CreateMaybeMessage<::joosc_fuzzer::IfThen>(Arena*);
template<> ::joosc_fuzzer::IntToBoolOp* Arena::CreateMaybeMessage<::joosc_fuzzer::IntToBoolOp>(Arena*);
template<> ::joosc_fuzzer::Lvalue* Arena::CreateMaybeMessage<::joosc_fuzzer::Lvalue>(Arena*);
template<> ::joosc_fuzzer::MethodInvocation* Arena::CreateMaybeMessage<::joosc_fuzzer::MethodInvocation>(Arena*);
template<> ::joosc_fuzzer::MethodInvocationStatement* Arena::CreateMaybeMessage<::joosc_fuzzer::MethodInvocationStatement>(Arena*);
template<> ::joosc_fuzzer::Rvalue* Arena::CreateMaybeMessage<::joosc_fuzzer::Rvalue>(Arena*);
template<> ::joosc_fuzzer::Statement* Arena::CreateMaybeMessage<::joosc_fuzzer::Statement>(Arena*);
template<> ::joosc_fuzzer::StatementSeq* Arena::CreateMaybeMessage<::joosc_fuzzer::StatementSeq>(Arena*);
template<> ::joosc_fuzzer::StaticField* Arena::CreateMaybeMessage<::joosc_fuzzer::StaticField>(Arena*);
template<> ::joosc_fuzzer::VarRef* Arena::CreateMaybeMessage<::joosc_fuzzer::VarRef>(Arena*);
template<> ::joosc_fuzzer::While* Arena::CreateMaybeMessage<::joosc_fuzzer::While>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace joosc_fuzzer {

enum BinaryOp_Op : int {
  BinaryOp_Op_ADD = 0,
  BinaryOp_Op_SUB = 1,
  BinaryOp_Op_MUL = 2,
  BinaryOp_Op_DIV = 3,
  BinaryOp_Op_MOD = 4
};
bool BinaryOp_Op_IsValid(int value);
constexpr BinaryOp_Op BinaryOp_Op_Op_MIN = BinaryOp_Op_ADD;
constexpr BinaryOp_Op BinaryOp_Op_Op_MAX = BinaryOp_Op_MOD;
constexpr int BinaryOp_Op_Op_ARRAYSIZE = BinaryOp_Op_Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryOp_Op_descriptor();
template<typename T>
inline const std::string& BinaryOp_Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryOp_Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryOp_Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BinaryOp_Op_descriptor(), enum_t_value);
}
inline bool BinaryOp_Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BinaryOp_Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BinaryOp_Op>(
    BinaryOp_Op_descriptor(), name, value);
}
enum BoolToBoolOp_Op : int {
  BoolToBoolOp_Op_AND = 0,
  BoolToBoolOp_Op_OR = 1,
  BoolToBoolOp_Op_EAND = 2,
  BoolToBoolOp_Op_EOR = 3,
  BoolToBoolOp_Op_EQ = 4,
  BoolToBoolOp_Op_NEQ = 5
};
bool BoolToBoolOp_Op_IsValid(int value);
constexpr BoolToBoolOp_Op BoolToBoolOp_Op_Op_MIN = BoolToBoolOp_Op_AND;
constexpr BoolToBoolOp_Op BoolToBoolOp_Op_Op_MAX = BoolToBoolOp_Op_NEQ;
constexpr int BoolToBoolOp_Op_Op_ARRAYSIZE = BoolToBoolOp_Op_Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BoolToBoolOp_Op_descriptor();
template<typename T>
inline const std::string& BoolToBoolOp_Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BoolToBoolOp_Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BoolToBoolOp_Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BoolToBoolOp_Op_descriptor(), enum_t_value);
}
inline bool BoolToBoolOp_Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BoolToBoolOp_Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BoolToBoolOp_Op>(
    BoolToBoolOp_Op_descriptor(), name, value);
}
enum IntToBoolOp_Op : int {
  IntToBoolOp_Op_LT = 0,
  IntToBoolOp_Op_GT = 1,
  IntToBoolOp_Op_LEQ = 2,
  IntToBoolOp_Op_GEQ = 3,
  IntToBoolOp_Op_EQ = 4,
  IntToBoolOp_Op_NEQ = 5
};
bool IntToBoolOp_Op_IsValid(int value);
constexpr IntToBoolOp_Op IntToBoolOp_Op_Op_MIN = IntToBoolOp_Op_LT;
constexpr IntToBoolOp_Op IntToBoolOp_Op_Op_MAX = IntToBoolOp_Op_NEQ;
constexpr int IntToBoolOp_Op_Op_ARRAYSIZE = IntToBoolOp_Op_Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntToBoolOp_Op_descriptor();
template<typename T>
inline const std::string& IntToBoolOp_Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IntToBoolOp_Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IntToBoolOp_Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IntToBoolOp_Op_descriptor(), enum_t_value);
}
inline bool IntToBoolOp_Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IntToBoolOp_Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IntToBoolOp_Op>(
    IntToBoolOp_Op_descriptor(), name, value);
}
// ===================================================================

class VarRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.VarRef) */ {
 public:
  inline VarRef() : VarRef(nullptr) {}
  ~VarRef() override;
  explicit PROTOBUF_CONSTEXPR VarRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarRef(const VarRef& from);
  VarRef(VarRef&& from) noexcept
    : VarRef() {
    *this = ::std::move(from);
  }

  inline VarRef& operator=(const VarRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarRef& operator=(VarRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarRef* internal_default_instance() {
    return reinterpret_cast<const VarRef*>(
               &_VarRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VarRef& a, VarRef& b) {
    a.Swap(&b);
  }
  inline void Swap(VarRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarRef& from) {
    VarRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.VarRef";
  }
  protected:
  explicit VarRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarnumFieldNumber = 1,
  };
  // required int32 varnum = 1;
  bool has_varnum() const;
  private:
  bool _internal_has_varnum() const;
  public:
  void clear_varnum();
  int32_t varnum() const;
  void set_varnum(int32_t value);
  private:
  int32_t _internal_varnum() const;
  void _internal_set_varnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.VarRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t varnum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class FunctionRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.FunctionRef) */ {
 public:
  inline FunctionRef() : FunctionRef(nullptr) {}
  ~FunctionRef() override;
  explicit PROTOBUF_CONSTEXPR FunctionRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionRef(const FunctionRef& from);
  FunctionRef(FunctionRef&& from) noexcept
    : FunctionRef() {
    *this = ::std::move(from);
  }

  inline FunctionRef& operator=(const FunctionRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionRef& operator=(FunctionRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionRef* internal_default_instance() {
    return reinterpret_cast<const FunctionRef*>(
               &_FunctionRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FunctionRef& a, FunctionRef& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionRef& from) {
    FunctionRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.FunctionRef";
  }
  protected:
  explicit FunctionRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncnumFieldNumber = 1,
  };
  // required int32 funcnum = 1;
  bool has_funcnum() const;
  private:
  bool _internal_has_funcnum() const;
  public:
  void clear_funcnum();
  int32_t funcnum() const;
  void set_funcnum(int32_t value);
  private:
  int32_t _internal_funcnum() const;
  void _internal_set_funcnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.FunctionRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t funcnum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class Lvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.Lvalue) */ {
 public:
  inline Lvalue() : Lvalue(nullptr) {}
  ~Lvalue() override;
  explicit PROTOBUF_CONSTEXPR Lvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lvalue(const Lvalue& from);
  Lvalue(Lvalue&& from) noexcept
    : Lvalue() {
    *this = ::std::move(from);
  }

  inline Lvalue& operator=(const Lvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lvalue& operator=(Lvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lvalue& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lvalue* internal_default_instance() {
    return reinterpret_cast<const Lvalue*>(
               &_Lvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Lvalue& a, Lvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(Lvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Lvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Lvalue& from) {
    Lvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.Lvalue";
  }
  protected:
  explicit Lvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarrefFieldNumber = 1,
  };
  // required .joosc_fuzzer.VarRef varref = 1;
  bool has_varref() const;
  private:
  bool _internal_has_varref() const;
  public:
  void clear_varref();
  const ::joosc_fuzzer::VarRef& varref() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::VarRef* release_varref();
  ::joosc_fuzzer::VarRef* mutable_varref();
  void set_allocated_varref(::joosc_fuzzer::VarRef* varref);
  private:
  const ::joosc_fuzzer::VarRef& _internal_varref() const;
  ::joosc_fuzzer::VarRef* _internal_mutable_varref();
  public:
  void unsafe_arena_set_allocated_varref(
      ::joosc_fuzzer::VarRef* varref);
  ::joosc_fuzzer::VarRef* unsafe_arena_release_varref();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.Lvalue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::VarRef* varref_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class Rvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.Rvalue) */ {
 public:
  inline Rvalue() : Rvalue(nullptr) {}
  ~Rvalue() override;
  explicit PROTOBUF_CONSTEXPR Rvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rvalue(const Rvalue& from);
  Rvalue(Rvalue&& from) noexcept
    : Rvalue() {
    *this = ::std::move(from);
  }

  inline Rvalue& operator=(const Rvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rvalue& operator=(Rvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rvalue& default_instance() {
    return *internal_default_instance();
  }
  enum RvalueOneofCase {
    kVarref = 1,
    kBinop = 2,
    RVALUE_ONEOF_NOT_SET = 0,
  };

  static inline const Rvalue* internal_default_instance() {
    return reinterpret_cast<const Rvalue*>(
               &_Rvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Rvalue& a, Rvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(Rvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rvalue& from) {
    Rvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.Rvalue";
  }
  protected:
  explicit Rvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsFieldNumber = 3,
    kVarrefFieldNumber = 1,
    kBinopFieldNumber = 2,
  };
  // required .joosc_fuzzer.Const cons = 3;
  bool has_cons() const;
  private:
  bool _internal_has_cons() const;
  public:
  void clear_cons();
  const ::joosc_fuzzer::Const& cons() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Const* release_cons();
  ::joosc_fuzzer::Const* mutable_cons();
  void set_allocated_cons(::joosc_fuzzer::Const* cons);
  private:
  const ::joosc_fuzzer::Const& _internal_cons() const;
  ::joosc_fuzzer::Const* _internal_mutable_cons();
  public:
  void unsafe_arena_set_allocated_cons(
      ::joosc_fuzzer::Const* cons);
  ::joosc_fuzzer::Const* unsafe_arena_release_cons();

  // .joosc_fuzzer.VarRef varref = 1;
  bool has_varref() const;
  private:
  bool _internal_has_varref() const;
  public:
  void clear_varref();
  const ::joosc_fuzzer::VarRef& varref() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::VarRef* release_varref();
  ::joosc_fuzzer::VarRef* mutable_varref();
  void set_allocated_varref(::joosc_fuzzer::VarRef* varref);
  private:
  const ::joosc_fuzzer::VarRef& _internal_varref() const;
  ::joosc_fuzzer::VarRef* _internal_mutable_varref();
  public:
  void unsafe_arena_set_allocated_varref(
      ::joosc_fuzzer::VarRef* varref);
  ::joosc_fuzzer::VarRef* unsafe_arena_release_varref();

  // .joosc_fuzzer.BinaryOp binop = 2;
  bool has_binop() const;
  private:
  bool _internal_has_binop() const;
  public:
  void clear_binop();
  const ::joosc_fuzzer::BinaryOp& binop() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::BinaryOp* release_binop();
  ::joosc_fuzzer::BinaryOp* mutable_binop();
  void set_allocated_binop(::joosc_fuzzer::BinaryOp* binop);
  private:
  const ::joosc_fuzzer::BinaryOp& _internal_binop() const;
  ::joosc_fuzzer::BinaryOp* _internal_mutable_binop();
  public:
  void unsafe_arena_set_allocated_binop(
      ::joosc_fuzzer::BinaryOp* binop);
  ::joosc_fuzzer::BinaryOp* unsafe_arena_release_binop();

  void clear_rvalue_oneof();
  RvalueOneofCase rvalue_oneof_case() const;
  // @@protoc_insertion_point(class_scope:joosc_fuzzer.Rvalue)
 private:
  class _Internal;
  void set_has_varref();
  void set_has_binop();

  inline bool has_rvalue_oneof() const;
  inline void clear_has_rvalue_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::Const* cons_;
    union RvalueOneofUnion {
      constexpr RvalueOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::joosc_fuzzer::VarRef* varref_;
      ::joosc_fuzzer::BinaryOp* binop_;
    } rvalue_oneof_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class Const final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.Const) */ {
 public:
  inline Const() : Const(nullptr) {}
  ~Const() override;
  explicit PROTOBUF_CONSTEXPR Const(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Const(const Const& from);
  Const(Const&& from) noexcept
    : Const() {
    *this = ::std::move(from);
  }

  inline Const& operator=(const Const& from) {
    CopyFrom(from);
    return *this;
  }
  inline Const& operator=(Const&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Const& default_instance() {
    return *internal_default_instance();
  }
  static inline const Const* internal_default_instance() {
    return reinterpret_cast<const Const*>(
               &_Const_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Const& a, Const& b) {
    a.Swap(&b);
  }
  inline void Swap(Const* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Const* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Const* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Const>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Const& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Const& from) {
    Const::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Const* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.Const";
  }
  protected:
  explicit Const(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // required int32 val = 1;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  int32_t val() const;
  void set_val(int32_t value);
  private:
  int32_t _internal_val() const;
  void _internal_set_val(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.Const)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t val_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class BinaryOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.BinaryOp) */ {
 public:
  inline BinaryOp() : BinaryOp(nullptr) {}
  ~BinaryOp() override;
  explicit PROTOBUF_CONSTEXPR BinaryOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOp(const BinaryOp& from);
  BinaryOp(BinaryOp&& from) noexcept
    : BinaryOp() {
    *this = ::std::move(from);
  }

  inline BinaryOp& operator=(const BinaryOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOp& operator=(BinaryOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOp* internal_default_instance() {
    return reinterpret_cast<const BinaryOp*>(
               &_BinaryOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BinaryOp& a, BinaryOp& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOp& from) {
    BinaryOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.BinaryOp";
  }
  protected:
  explicit BinaryOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BinaryOp_Op Op;
  static constexpr Op ADD =
    BinaryOp_Op_ADD;
  static constexpr Op SUB =
    BinaryOp_Op_SUB;
  static constexpr Op MUL =
    BinaryOp_Op_MUL;
  static constexpr Op DIV =
    BinaryOp_Op_DIV;
  static constexpr Op MOD =
    BinaryOp_Op_MOD;
  static inline bool Op_IsValid(int value) {
    return BinaryOp_Op_IsValid(value);
  }
  static constexpr Op Op_MIN =
    BinaryOp_Op_Op_MIN;
  static constexpr Op Op_MAX =
    BinaryOp_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE =
    BinaryOp_Op_Op_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Op_descriptor() {
    return BinaryOp_Op_descriptor();
  }
  template<typename T>
  static inline const std::string& Op_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Op>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Op_Name.");
    return BinaryOp_Op_Name(enum_t_value);
  }
  static inline bool Op_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Op* value) {
    return BinaryOp_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kOpFieldNumber = 1,
  };
  // required .joosc_fuzzer.Rvalue left = 2;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  const ::joosc_fuzzer::Rvalue& left() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Rvalue* release_left();
  ::joosc_fuzzer::Rvalue* mutable_left();
  void set_allocated_left(::joosc_fuzzer::Rvalue* left);
  private:
  const ::joosc_fuzzer::Rvalue& _internal_left() const;
  ::joosc_fuzzer::Rvalue* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::joosc_fuzzer::Rvalue* left);
  ::joosc_fuzzer::Rvalue* unsafe_arena_release_left();

  // required .joosc_fuzzer.Rvalue right = 3;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  const ::joosc_fuzzer::Rvalue& right() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Rvalue* release_right();
  ::joosc_fuzzer::Rvalue* mutable_right();
  void set_allocated_right(::joosc_fuzzer::Rvalue* right);
  private:
  const ::joosc_fuzzer::Rvalue& _internal_right() const;
  ::joosc_fuzzer::Rvalue* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::joosc_fuzzer::Rvalue* right);
  ::joosc_fuzzer::Rvalue* unsafe_arena_release_right();

  // required .joosc_fuzzer.BinaryOp.Op op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  ::joosc_fuzzer::BinaryOp_Op op() const;
  void set_op(::joosc_fuzzer::BinaryOp_Op value);
  private:
  ::joosc_fuzzer::BinaryOp_Op _internal_op() const;
  void _internal_set_op(::joosc_fuzzer::BinaryOp_Op value);
  public:

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.BinaryOp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::Rvalue* left_;
    ::joosc_fuzzer::Rvalue* right_;
    int op_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class BoolRvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.BoolRvalue) */ {
 public:
  inline BoolRvalue() : BoolRvalue(nullptr) {}
  ~BoolRvalue() override;
  explicit PROTOBUF_CONSTEXPR BoolRvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolRvalue(const BoolRvalue& from);
  BoolRvalue(BoolRvalue&& from) noexcept
    : BoolRvalue() {
    *this = ::std::move(from);
  }

  inline BoolRvalue& operator=(const BoolRvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolRvalue& operator=(BoolRvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolRvalue& default_instance() {
    return *internal_default_instance();
  }
  enum BoolBinopOneofCase {
    kBoolop = 1,
    kIntop = 2,
    BOOL_BINOP_ONEOF_NOT_SET = 0,
  };

  static inline const BoolRvalue* internal_default_instance() {
    return reinterpret_cast<const BoolRvalue*>(
               &_BoolRvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BoolRvalue& a, BoolRvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolRvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolRvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolRvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolRvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolRvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolRvalue& from) {
    BoolRvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolRvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.BoolRvalue";
  }
  protected:
  explicit BoolRvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsFieldNumber = 3,
    kBoolopFieldNumber = 1,
    kIntopFieldNumber = 2,
  };
  // required bool cons = 3;
  bool has_cons() const;
  private:
  bool _internal_has_cons() const;
  public:
  void clear_cons();
  bool cons() const;
  void set_cons(bool value);
  private:
  bool _internal_cons() const;
  void _internal_set_cons(bool value);
  public:

  // .joosc_fuzzer.BoolToBoolOp boolop = 1;
  bool has_boolop() const;
  private:
  bool _internal_has_boolop() const;
  public:
  void clear_boolop();
  const ::joosc_fuzzer::BoolToBoolOp& boolop() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::BoolToBoolOp* release_boolop();
  ::joosc_fuzzer::BoolToBoolOp* mutable_boolop();
  void set_allocated_boolop(::joosc_fuzzer::BoolToBoolOp* boolop);
  private:
  const ::joosc_fuzzer::BoolToBoolOp& _internal_boolop() const;
  ::joosc_fuzzer::BoolToBoolOp* _internal_mutable_boolop();
  public:
  void unsafe_arena_set_allocated_boolop(
      ::joosc_fuzzer::BoolToBoolOp* boolop);
  ::joosc_fuzzer::BoolToBoolOp* unsafe_arena_release_boolop();

  // .joosc_fuzzer.IntToBoolOp intop = 2;
  bool has_intop() const;
  private:
  bool _internal_has_intop() const;
  public:
  void clear_intop();
  const ::joosc_fuzzer::IntToBoolOp& intop() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::IntToBoolOp* release_intop();
  ::joosc_fuzzer::IntToBoolOp* mutable_intop();
  void set_allocated_intop(::joosc_fuzzer::IntToBoolOp* intop);
  private:
  const ::joosc_fuzzer::IntToBoolOp& _internal_intop() const;
  ::joosc_fuzzer::IntToBoolOp* _internal_mutable_intop();
  public:
  void unsafe_arena_set_allocated_intop(
      ::joosc_fuzzer::IntToBoolOp* intop);
  ::joosc_fuzzer::IntToBoolOp* unsafe_arena_release_intop();

  void clear_bool_binop_oneof();
  BoolBinopOneofCase bool_binop_oneof_case() const;
  // @@protoc_insertion_point(class_scope:joosc_fuzzer.BoolRvalue)
 private:
  class _Internal;
  void set_has_boolop();
  void set_has_intop();

  inline bool has_bool_binop_oneof() const;
  inline void clear_has_bool_binop_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool cons_;
    union BoolBinopOneofUnion {
      constexpr BoolBinopOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::joosc_fuzzer::BoolToBoolOp* boolop_;
      ::joosc_fuzzer::IntToBoolOp* intop_;
    } bool_binop_oneof_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class BoolToBoolOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.BoolToBoolOp) */ {
 public:
  inline BoolToBoolOp() : BoolToBoolOp(nullptr) {}
  ~BoolToBoolOp() override;
  explicit PROTOBUF_CONSTEXPR BoolToBoolOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolToBoolOp(const BoolToBoolOp& from);
  BoolToBoolOp(BoolToBoolOp&& from) noexcept
    : BoolToBoolOp() {
    *this = ::std::move(from);
  }

  inline BoolToBoolOp& operator=(const BoolToBoolOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolToBoolOp& operator=(BoolToBoolOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolToBoolOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolToBoolOp* internal_default_instance() {
    return reinterpret_cast<const BoolToBoolOp*>(
               &_BoolToBoolOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BoolToBoolOp& a, BoolToBoolOp& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolToBoolOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolToBoolOp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolToBoolOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolToBoolOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolToBoolOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolToBoolOp& from) {
    BoolToBoolOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolToBoolOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.BoolToBoolOp";
  }
  protected:
  explicit BoolToBoolOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BoolToBoolOp_Op Op;
  static constexpr Op AND =
    BoolToBoolOp_Op_AND;
  static constexpr Op OR =
    BoolToBoolOp_Op_OR;
  static constexpr Op EAND =
    BoolToBoolOp_Op_EAND;
  static constexpr Op EOR =
    BoolToBoolOp_Op_EOR;
  static constexpr Op EQ =
    BoolToBoolOp_Op_EQ;
  static constexpr Op NEQ =
    BoolToBoolOp_Op_NEQ;
  static inline bool Op_IsValid(int value) {
    return BoolToBoolOp_Op_IsValid(value);
  }
  static constexpr Op Op_MIN =
    BoolToBoolOp_Op_Op_MIN;
  static constexpr Op Op_MAX =
    BoolToBoolOp_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE =
    BoolToBoolOp_Op_Op_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Op_descriptor() {
    return BoolToBoolOp_Op_descriptor();
  }
  template<typename T>
  static inline const std::string& Op_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Op>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Op_Name.");
    return BoolToBoolOp_Op_Name(enum_t_value);
  }
  static inline bool Op_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Op* value) {
    return BoolToBoolOp_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kOpFieldNumber = 1,
  };
  // required .joosc_fuzzer.BoolRvalue left = 2;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  const ::joosc_fuzzer::BoolRvalue& left() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::BoolRvalue* release_left();
  ::joosc_fuzzer::BoolRvalue* mutable_left();
  void set_allocated_left(::joosc_fuzzer::BoolRvalue* left);
  private:
  const ::joosc_fuzzer::BoolRvalue& _internal_left() const;
  ::joosc_fuzzer::BoolRvalue* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::joosc_fuzzer::BoolRvalue* left);
  ::joosc_fuzzer::BoolRvalue* unsafe_arena_release_left();

  // required .joosc_fuzzer.BoolRvalue right = 3;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  const ::joosc_fuzzer::BoolRvalue& right() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::BoolRvalue* release_right();
  ::joosc_fuzzer::BoolRvalue* mutable_right();
  void set_allocated_right(::joosc_fuzzer::BoolRvalue* right);
  private:
  const ::joosc_fuzzer::BoolRvalue& _internal_right() const;
  ::joosc_fuzzer::BoolRvalue* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::joosc_fuzzer::BoolRvalue* right);
  ::joosc_fuzzer::BoolRvalue* unsafe_arena_release_right();

  // required .joosc_fuzzer.BoolToBoolOp.Op op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  ::joosc_fuzzer::BoolToBoolOp_Op op() const;
  void set_op(::joosc_fuzzer::BoolToBoolOp_Op value);
  private:
  ::joosc_fuzzer::BoolToBoolOp_Op _internal_op() const;
  void _internal_set_op(::joosc_fuzzer::BoolToBoolOp_Op value);
  public:

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.BoolToBoolOp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::BoolRvalue* left_;
    ::joosc_fuzzer::BoolRvalue* right_;
    int op_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class IntToBoolOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.IntToBoolOp) */ {
 public:
  inline IntToBoolOp() : IntToBoolOp(nullptr) {}
  ~IntToBoolOp() override;
  explicit PROTOBUF_CONSTEXPR IntToBoolOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntToBoolOp(const IntToBoolOp& from);
  IntToBoolOp(IntToBoolOp&& from) noexcept
    : IntToBoolOp() {
    *this = ::std::move(from);
  }

  inline IntToBoolOp& operator=(const IntToBoolOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntToBoolOp& operator=(IntToBoolOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntToBoolOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntToBoolOp* internal_default_instance() {
    return reinterpret_cast<const IntToBoolOp*>(
               &_IntToBoolOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IntToBoolOp& a, IntToBoolOp& b) {
    a.Swap(&b);
  }
  inline void Swap(IntToBoolOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntToBoolOp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntToBoolOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntToBoolOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntToBoolOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntToBoolOp& from) {
    IntToBoolOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntToBoolOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.IntToBoolOp";
  }
  protected:
  explicit IntToBoolOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IntToBoolOp_Op Op;
  static constexpr Op LT =
    IntToBoolOp_Op_LT;
  static constexpr Op GT =
    IntToBoolOp_Op_GT;
  static constexpr Op LEQ =
    IntToBoolOp_Op_LEQ;
  static constexpr Op GEQ =
    IntToBoolOp_Op_GEQ;
  static constexpr Op EQ =
    IntToBoolOp_Op_EQ;
  static constexpr Op NEQ =
    IntToBoolOp_Op_NEQ;
  static inline bool Op_IsValid(int value) {
    return IntToBoolOp_Op_IsValid(value);
  }
  static constexpr Op Op_MIN =
    IntToBoolOp_Op_Op_MIN;
  static constexpr Op Op_MAX =
    IntToBoolOp_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE =
    IntToBoolOp_Op_Op_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Op_descriptor() {
    return IntToBoolOp_Op_descriptor();
  }
  template<typename T>
  static inline const std::string& Op_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Op>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Op_Name.");
    return IntToBoolOp_Op_Name(enum_t_value);
  }
  static inline bool Op_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Op* value) {
    return IntToBoolOp_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kOpFieldNumber = 1,
  };
  // required .joosc_fuzzer.Rvalue left = 2;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  const ::joosc_fuzzer::Rvalue& left() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Rvalue* release_left();
  ::joosc_fuzzer::Rvalue* mutable_left();
  void set_allocated_left(::joosc_fuzzer::Rvalue* left);
  private:
  const ::joosc_fuzzer::Rvalue& _internal_left() const;
  ::joosc_fuzzer::Rvalue* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::joosc_fuzzer::Rvalue* left);
  ::joosc_fuzzer::Rvalue* unsafe_arena_release_left();

  // required .joosc_fuzzer.Rvalue right = 3;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  const ::joosc_fuzzer::Rvalue& right() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Rvalue* release_right();
  ::joosc_fuzzer::Rvalue* mutable_right();
  void set_allocated_right(::joosc_fuzzer::Rvalue* right);
  private:
  const ::joosc_fuzzer::Rvalue& _internal_right() const;
  ::joosc_fuzzer::Rvalue* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::joosc_fuzzer::Rvalue* right);
  ::joosc_fuzzer::Rvalue* unsafe_arena_release_right();

  // required .joosc_fuzzer.IntToBoolOp.Op op = 1;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  ::joosc_fuzzer::IntToBoolOp_Op op() const;
  void set_op(::joosc_fuzzer::IntToBoolOp_Op value);
  private:
  ::joosc_fuzzer::IntToBoolOp_Op _internal_op() const;
  void _internal_set_op(::joosc_fuzzer::IntToBoolOp_Op value);
  public:

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.IntToBoolOp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::Rvalue* left_;
    ::joosc_fuzzer::Rvalue* right_;
    int op_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class AssignmentStatement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.AssignmentStatement) */ {
 public:
  inline AssignmentStatement() : AssignmentStatement(nullptr) {}
  ~AssignmentStatement() override;
  explicit PROTOBUF_CONSTEXPR AssignmentStatement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssignmentStatement(const AssignmentStatement& from);
  AssignmentStatement(AssignmentStatement&& from) noexcept
    : AssignmentStatement() {
    *this = ::std::move(from);
  }

  inline AssignmentStatement& operator=(const AssignmentStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignmentStatement& operator=(AssignmentStatement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignmentStatement& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignmentStatement* internal_default_instance() {
    return reinterpret_cast<const AssignmentStatement*>(
               &_AssignmentStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AssignmentStatement& a, AssignmentStatement& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignmentStatement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignmentStatement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignmentStatement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssignmentStatement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssignmentStatement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssignmentStatement& from) {
    AssignmentStatement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignmentStatement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.AssignmentStatement";
  }
  protected:
  explicit AssignmentStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLvalueFieldNumber = 1,
    kRvalueFieldNumber = 2,
  };
  // required .joosc_fuzzer.Lvalue lvalue = 1;
  bool has_lvalue() const;
  private:
  bool _internal_has_lvalue() const;
  public:
  void clear_lvalue();
  const ::joosc_fuzzer::Lvalue& lvalue() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Lvalue* release_lvalue();
  ::joosc_fuzzer::Lvalue* mutable_lvalue();
  void set_allocated_lvalue(::joosc_fuzzer::Lvalue* lvalue);
  private:
  const ::joosc_fuzzer::Lvalue& _internal_lvalue() const;
  ::joosc_fuzzer::Lvalue* _internal_mutable_lvalue();
  public:
  void unsafe_arena_set_allocated_lvalue(
      ::joosc_fuzzer::Lvalue* lvalue);
  ::joosc_fuzzer::Lvalue* unsafe_arena_release_lvalue();

  // required .joosc_fuzzer.Rvalue rvalue = 2;
  bool has_rvalue() const;
  private:
  bool _internal_has_rvalue() const;
  public:
  void clear_rvalue();
  const ::joosc_fuzzer::Rvalue& rvalue() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Rvalue* release_rvalue();
  ::joosc_fuzzer::Rvalue* mutable_rvalue();
  void set_allocated_rvalue(::joosc_fuzzer::Rvalue* rvalue);
  private:
  const ::joosc_fuzzer::Rvalue& _internal_rvalue() const;
  ::joosc_fuzzer::Rvalue* _internal_mutable_rvalue();
  public:
  void unsafe_arena_set_allocated_rvalue(
      ::joosc_fuzzer::Rvalue* rvalue);
  ::joosc_fuzzer::Rvalue* unsafe_arena_release_rvalue();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.AssignmentStatement)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::Lvalue* lvalue_;
    ::joosc_fuzzer::Rvalue* rvalue_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class MethodInvocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.MethodInvocation) */ {
 public:
  inline MethodInvocation() : MethodInvocation(nullptr) {}
  ~MethodInvocation() override;
  explicit PROTOBUF_CONSTEXPR MethodInvocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MethodInvocation(const MethodInvocation& from);
  MethodInvocation(MethodInvocation&& from) noexcept
    : MethodInvocation() {
    *this = ::std::move(from);
  }

  inline MethodInvocation& operator=(const MethodInvocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline MethodInvocation& operator=(MethodInvocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MethodInvocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const MethodInvocation* internal_default_instance() {
    return reinterpret_cast<const MethodInvocation*>(
               &_MethodInvocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MethodInvocation& a, MethodInvocation& b) {
    a.Swap(&b);
  }
  inline void Swap(MethodInvocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MethodInvocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MethodInvocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MethodInvocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MethodInvocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MethodInvocation& from) {
    MethodInvocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MethodInvocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.MethodInvocation";
  }
  protected:
  explicit MethodInvocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncrefFieldNumber = 1,
  };
  // required .joosc_fuzzer.FunctionRef funcref = 1;
  bool has_funcref() const;
  private:
  bool _internal_has_funcref() const;
  public:
  void clear_funcref();
  const ::joosc_fuzzer::FunctionRef& funcref() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::FunctionRef* release_funcref();
  ::joosc_fuzzer::FunctionRef* mutable_funcref();
  void set_allocated_funcref(::joosc_fuzzer::FunctionRef* funcref);
  private:
  const ::joosc_fuzzer::FunctionRef& _internal_funcref() const;
  ::joosc_fuzzer::FunctionRef* _internal_mutable_funcref();
  public:
  void unsafe_arena_set_allocated_funcref(
      ::joosc_fuzzer::FunctionRef* funcref);
  ::joosc_fuzzer::FunctionRef* unsafe_arena_release_funcref();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.MethodInvocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::FunctionRef* funcref_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class MethodInvocationStatement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.MethodInvocationStatement) */ {
 public:
  inline MethodInvocationStatement() : MethodInvocationStatement(nullptr) {}
  ~MethodInvocationStatement() override;
  explicit PROTOBUF_CONSTEXPR MethodInvocationStatement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MethodInvocationStatement(const MethodInvocationStatement& from);
  MethodInvocationStatement(MethodInvocationStatement&& from) noexcept
    : MethodInvocationStatement() {
    *this = ::std::move(from);
  }

  inline MethodInvocationStatement& operator=(const MethodInvocationStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline MethodInvocationStatement& operator=(MethodInvocationStatement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MethodInvocationStatement& default_instance() {
    return *internal_default_instance();
  }
  static inline const MethodInvocationStatement* internal_default_instance() {
    return reinterpret_cast<const MethodInvocationStatement*>(
               &_MethodInvocationStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MethodInvocationStatement& a, MethodInvocationStatement& b) {
    a.Swap(&b);
  }
  inline void Swap(MethodInvocationStatement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MethodInvocationStatement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MethodInvocationStatement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MethodInvocationStatement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MethodInvocationStatement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MethodInvocationStatement& from) {
    MethodInvocationStatement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MethodInvocationStatement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.MethodInvocationStatement";
  }
  protected:
  explicit MethodInvocationStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodInvocationFieldNumber = 1,
  };
  // required .joosc_fuzzer.MethodInvocation method_invocation = 1;
  bool has_method_invocation() const;
  private:
  bool _internal_has_method_invocation() const;
  public:
  void clear_method_invocation();
  const ::joosc_fuzzer::MethodInvocation& method_invocation() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::MethodInvocation* release_method_invocation();
  ::joosc_fuzzer::MethodInvocation* mutable_method_invocation();
  void set_allocated_method_invocation(::joosc_fuzzer::MethodInvocation* method_invocation);
  private:
  const ::joosc_fuzzer::MethodInvocation& _internal_method_invocation() const;
  ::joosc_fuzzer::MethodInvocation* _internal_mutable_method_invocation();
  public:
  void unsafe_arena_set_allocated_method_invocation(
      ::joosc_fuzzer::MethodInvocation* method_invocation);
  ::joosc_fuzzer::MethodInvocation* unsafe_arena_release_method_invocation();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.MethodInvocationStatement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::MethodInvocation* method_invocation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class IfThen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.IfThen) */ {
 public:
  inline IfThen() : IfThen(nullptr) {}
  ~IfThen() override;
  explicit PROTOBUF_CONSTEXPR IfThen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfThen(const IfThen& from);
  IfThen(IfThen&& from) noexcept
    : IfThen() {
    *this = ::std::move(from);
  }

  inline IfThen& operator=(const IfThen& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfThen& operator=(IfThen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfThen& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfThen* internal_default_instance() {
    return reinterpret_cast<const IfThen*>(
               &_IfThen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(IfThen& a, IfThen& b) {
    a.Swap(&b);
  }
  inline void Swap(IfThen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfThen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IfThen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IfThen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfThen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IfThen& from) {
    IfThen::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfThen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.IfThen";
  }
  protected:
  explicit IfThen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCondFieldNumber = 1,
    kIfBodyFieldNumber = 2,
  };
  // required .joosc_fuzzer.BoolRvalue cond = 1;
  bool has_cond() const;
  private:
  bool _internal_has_cond() const;
  public:
  void clear_cond();
  const ::joosc_fuzzer::BoolRvalue& cond() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::BoolRvalue* release_cond();
  ::joosc_fuzzer::BoolRvalue* mutable_cond();
  void set_allocated_cond(::joosc_fuzzer::BoolRvalue* cond);
  private:
  const ::joosc_fuzzer::BoolRvalue& _internal_cond() const;
  ::joosc_fuzzer::BoolRvalue* _internal_mutable_cond();
  public:
  void unsafe_arena_set_allocated_cond(
      ::joosc_fuzzer::BoolRvalue* cond);
  ::joosc_fuzzer::BoolRvalue* unsafe_arena_release_cond();

  // required .joosc_fuzzer.StatementSeq if_body = 2;
  bool has_if_body() const;
  private:
  bool _internal_has_if_body() const;
  public:
  void clear_if_body();
  const ::joosc_fuzzer::StatementSeq& if_body() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::StatementSeq* release_if_body();
  ::joosc_fuzzer::StatementSeq* mutable_if_body();
  void set_allocated_if_body(::joosc_fuzzer::StatementSeq* if_body);
  private:
  const ::joosc_fuzzer::StatementSeq& _internal_if_body() const;
  ::joosc_fuzzer::StatementSeq* _internal_mutable_if_body();
  public:
  void unsafe_arena_set_allocated_if_body(
      ::joosc_fuzzer::StatementSeq* if_body);
  ::joosc_fuzzer::StatementSeq* unsafe_arena_release_if_body();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.IfThen)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::BoolRvalue* cond_;
    ::joosc_fuzzer::StatementSeq* if_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class IfElse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.IfElse) */ {
 public:
  inline IfElse() : IfElse(nullptr) {}
  ~IfElse() override;
  explicit PROTOBUF_CONSTEXPR IfElse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfElse(const IfElse& from);
  IfElse(IfElse&& from) noexcept
    : IfElse() {
    *this = ::std::move(from);
  }

  inline IfElse& operator=(const IfElse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfElse& operator=(IfElse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfElse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfElse* internal_default_instance() {
    return reinterpret_cast<const IfElse*>(
               &_IfElse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IfElse& a, IfElse& b) {
    a.Swap(&b);
  }
  inline void Swap(IfElse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfElse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IfElse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IfElse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfElse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IfElse& from) {
    IfElse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfElse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.IfElse";
  }
  protected:
  explicit IfElse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCondFieldNumber = 1,
    kIfBodyFieldNumber = 2,
    kElseBodyFieldNumber = 3,
  };
  // required .joosc_fuzzer.BoolRvalue cond = 1;
  bool has_cond() const;
  private:
  bool _internal_has_cond() const;
  public:
  void clear_cond();
  const ::joosc_fuzzer::BoolRvalue& cond() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::BoolRvalue* release_cond();
  ::joosc_fuzzer::BoolRvalue* mutable_cond();
  void set_allocated_cond(::joosc_fuzzer::BoolRvalue* cond);
  private:
  const ::joosc_fuzzer::BoolRvalue& _internal_cond() const;
  ::joosc_fuzzer::BoolRvalue* _internal_mutable_cond();
  public:
  void unsafe_arena_set_allocated_cond(
      ::joosc_fuzzer::BoolRvalue* cond);
  ::joosc_fuzzer::BoolRvalue* unsafe_arena_release_cond();

  // required .joosc_fuzzer.StatementSeq if_body = 2;
  bool has_if_body() const;
  private:
  bool _internal_has_if_body() const;
  public:
  void clear_if_body();
  const ::joosc_fuzzer::StatementSeq& if_body() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::StatementSeq* release_if_body();
  ::joosc_fuzzer::StatementSeq* mutable_if_body();
  void set_allocated_if_body(::joosc_fuzzer::StatementSeq* if_body);
  private:
  const ::joosc_fuzzer::StatementSeq& _internal_if_body() const;
  ::joosc_fuzzer::StatementSeq* _internal_mutable_if_body();
  public:
  void unsafe_arena_set_allocated_if_body(
      ::joosc_fuzzer::StatementSeq* if_body);
  ::joosc_fuzzer::StatementSeq* unsafe_arena_release_if_body();

  // required .joosc_fuzzer.StatementSeq else_body = 3;
  bool has_else_body() const;
  private:
  bool _internal_has_else_body() const;
  public:
  void clear_else_body();
  const ::joosc_fuzzer::StatementSeq& else_body() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::StatementSeq* release_else_body();
  ::joosc_fuzzer::StatementSeq* mutable_else_body();
  void set_allocated_else_body(::joosc_fuzzer::StatementSeq* else_body);
  private:
  const ::joosc_fuzzer::StatementSeq& _internal_else_body() const;
  ::joosc_fuzzer::StatementSeq* _internal_mutable_else_body();
  public:
  void unsafe_arena_set_allocated_else_body(
      ::joosc_fuzzer::StatementSeq* else_body);
  ::joosc_fuzzer::StatementSeq* unsafe_arena_release_else_body();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.IfElse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::BoolRvalue* cond_;
    ::joosc_fuzzer::StatementSeq* if_body_;
    ::joosc_fuzzer::StatementSeq* else_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class While final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.While) */ {
 public:
  inline While() : While(nullptr) {}
  ~While() override;
  explicit PROTOBUF_CONSTEXPR While(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  While(const While& from);
  While(While&& from) noexcept
    : While() {
    *this = ::std::move(from);
  }

  inline While& operator=(const While& from) {
    CopyFrom(from);
    return *this;
  }
  inline While& operator=(While&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const While& default_instance() {
    return *internal_default_instance();
  }
  static inline const While* internal_default_instance() {
    return reinterpret_cast<const While*>(
               &_While_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(While& a, While& b) {
    a.Swap(&b);
  }
  inline void Swap(While* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(While* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  While* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<While>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const While& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const While& from) {
    While::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(While* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.While";
  }
  protected:
  explicit While(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCondFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // required .joosc_fuzzer.BoolRvalue cond = 1;
  bool has_cond() const;
  private:
  bool _internal_has_cond() const;
  public:
  void clear_cond();
  const ::joosc_fuzzer::BoolRvalue& cond() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::BoolRvalue* release_cond();
  ::joosc_fuzzer::BoolRvalue* mutable_cond();
  void set_allocated_cond(::joosc_fuzzer::BoolRvalue* cond);
  private:
  const ::joosc_fuzzer::BoolRvalue& _internal_cond() const;
  ::joosc_fuzzer::BoolRvalue* _internal_mutable_cond();
  public:
  void unsafe_arena_set_allocated_cond(
      ::joosc_fuzzer::BoolRvalue* cond);
  ::joosc_fuzzer::BoolRvalue* unsafe_arena_release_cond();

  // required .joosc_fuzzer.StatementSeq body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::joosc_fuzzer::StatementSeq& body() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::StatementSeq* release_body();
  ::joosc_fuzzer::StatementSeq* mutable_body();
  void set_allocated_body(::joosc_fuzzer::StatementSeq* body);
  private:
  const ::joosc_fuzzer::StatementSeq& _internal_body() const;
  ::joosc_fuzzer::StatementSeq* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::joosc_fuzzer::StatementSeq* body);
  ::joosc_fuzzer::StatementSeq* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.While)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::BoolRvalue* cond_;
    ::joosc_fuzzer::StatementSeq* body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class Statement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.Statement) */ {
 public:
  inline Statement() : Statement(nullptr) {}
  ~Statement() override;
  explicit PROTOBUF_CONSTEXPR Statement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statement(const Statement& from);
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement& operator=(Statement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement& default_instance() {
    return *internal_default_instance();
  }
  enum StmtOneofCase {
    kAssignment = 1,
    kIfthen = 2,
    kIfelse = 3,
    kWhileLoop = 4,
    STMT_ONEOF_NOT_SET = 0,
  };

  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }
  inline void Swap(Statement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Statement& from) {
    Statement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.Statement";
  }
  protected:
  explicit Statement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodCallFieldNumber = 5,
    kAssignmentFieldNumber = 1,
    kIfthenFieldNumber = 2,
    kIfelseFieldNumber = 3,
    kWhileLoopFieldNumber = 4,
  };
  // required .joosc_fuzzer.MethodInvocationStatement method_call = 5;
  bool has_method_call() const;
  private:
  bool _internal_has_method_call() const;
  public:
  void clear_method_call();
  const ::joosc_fuzzer::MethodInvocationStatement& method_call() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::MethodInvocationStatement* release_method_call();
  ::joosc_fuzzer::MethodInvocationStatement* mutable_method_call();
  void set_allocated_method_call(::joosc_fuzzer::MethodInvocationStatement* method_call);
  private:
  const ::joosc_fuzzer::MethodInvocationStatement& _internal_method_call() const;
  ::joosc_fuzzer::MethodInvocationStatement* _internal_mutable_method_call();
  public:
  void unsafe_arena_set_allocated_method_call(
      ::joosc_fuzzer::MethodInvocationStatement* method_call);
  ::joosc_fuzzer::MethodInvocationStatement* unsafe_arena_release_method_call();

  // .joosc_fuzzer.AssignmentStatement assignment = 1;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;
  public:
  void clear_assignment();
  const ::joosc_fuzzer::AssignmentStatement& assignment() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::AssignmentStatement* release_assignment();
  ::joosc_fuzzer::AssignmentStatement* mutable_assignment();
  void set_allocated_assignment(::joosc_fuzzer::AssignmentStatement* assignment);
  private:
  const ::joosc_fuzzer::AssignmentStatement& _internal_assignment() const;
  ::joosc_fuzzer::AssignmentStatement* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::joosc_fuzzer::AssignmentStatement* assignment);
  ::joosc_fuzzer::AssignmentStatement* unsafe_arena_release_assignment();

  // .joosc_fuzzer.IfThen ifthen = 2;
  bool has_ifthen() const;
  private:
  bool _internal_has_ifthen() const;
  public:
  void clear_ifthen();
  const ::joosc_fuzzer::IfThen& ifthen() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::IfThen* release_ifthen();
  ::joosc_fuzzer::IfThen* mutable_ifthen();
  void set_allocated_ifthen(::joosc_fuzzer::IfThen* ifthen);
  private:
  const ::joosc_fuzzer::IfThen& _internal_ifthen() const;
  ::joosc_fuzzer::IfThen* _internal_mutable_ifthen();
  public:
  void unsafe_arena_set_allocated_ifthen(
      ::joosc_fuzzer::IfThen* ifthen);
  ::joosc_fuzzer::IfThen* unsafe_arena_release_ifthen();

  // .joosc_fuzzer.IfElse ifelse = 3;
  bool has_ifelse() const;
  private:
  bool _internal_has_ifelse() const;
  public:
  void clear_ifelse();
  const ::joosc_fuzzer::IfElse& ifelse() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::IfElse* release_ifelse();
  ::joosc_fuzzer::IfElse* mutable_ifelse();
  void set_allocated_ifelse(::joosc_fuzzer::IfElse* ifelse);
  private:
  const ::joosc_fuzzer::IfElse& _internal_ifelse() const;
  ::joosc_fuzzer::IfElse* _internal_mutable_ifelse();
  public:
  void unsafe_arena_set_allocated_ifelse(
      ::joosc_fuzzer::IfElse* ifelse);
  ::joosc_fuzzer::IfElse* unsafe_arena_release_ifelse();

  // .joosc_fuzzer.While while_loop = 4;
  bool has_while_loop() const;
  private:
  bool _internal_has_while_loop() const;
  public:
  void clear_while_loop();
  const ::joosc_fuzzer::While& while_loop() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::While* release_while_loop();
  ::joosc_fuzzer::While* mutable_while_loop();
  void set_allocated_while_loop(::joosc_fuzzer::While* while_loop);
  private:
  const ::joosc_fuzzer::While& _internal_while_loop() const;
  ::joosc_fuzzer::While* _internal_mutable_while_loop();
  public:
  void unsafe_arena_set_allocated_while_loop(
      ::joosc_fuzzer::While* while_loop);
  ::joosc_fuzzer::While* unsafe_arena_release_while_loop();

  void clear_stmt_oneof();
  StmtOneofCase stmt_oneof_case() const;
  // @@protoc_insertion_point(class_scope:joosc_fuzzer.Statement)
 private:
  class _Internal;
  void set_has_assignment();
  void set_has_ifthen();
  void set_has_ifelse();
  void set_has_while_loop();

  inline bool has_stmt_oneof() const;
  inline void clear_has_stmt_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::MethodInvocationStatement* method_call_;
    union StmtOneofUnion {
      constexpr StmtOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::joosc_fuzzer::AssignmentStatement* assignment_;
      ::joosc_fuzzer::IfThen* ifthen_;
      ::joosc_fuzzer::IfElse* ifelse_;
      ::joosc_fuzzer::While* while_loop_;
    } stmt_oneof_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class StatementSeq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.StatementSeq) */ {
 public:
  inline StatementSeq() : StatementSeq(nullptr) {}
  ~StatementSeq() override;
  explicit PROTOBUF_CONSTEXPR StatementSeq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatementSeq(const StatementSeq& from);
  StatementSeq(StatementSeq&& from) noexcept
    : StatementSeq() {
    *this = ::std::move(from);
  }

  inline StatementSeq& operator=(const StatementSeq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatementSeq& operator=(StatementSeq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatementSeq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatementSeq* internal_default_instance() {
    return reinterpret_cast<const StatementSeq*>(
               &_StatementSeq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StatementSeq& a, StatementSeq& b) {
    a.Swap(&b);
  }
  inline void Swap(StatementSeq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatementSeq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatementSeq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatementSeq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatementSeq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatementSeq& from) {
    StatementSeq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatementSeq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.StatementSeq";
  }
  protected:
  explicit StatementSeq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 1,
  };
  // repeated .joosc_fuzzer.Statement statements = 1;
  int statements_size() const;
  private:
  int _internal_statements_size() const;
  public:
  void clear_statements();
  ::joosc_fuzzer::Statement* mutable_statements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::Statement >*
      mutable_statements();
  private:
  const ::joosc_fuzzer::Statement& _internal_statements(int index) const;
  ::joosc_fuzzer::Statement* _internal_add_statements();
  public:
  const ::joosc_fuzzer::Statement& statements(int index) const;
  ::joosc_fuzzer::Statement* add_statements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::Statement >&
      statements() const;

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.StatementSeq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::Statement > statements_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class StaticField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.StaticField) */ {
 public:
  inline StaticField() : StaticField(nullptr) {}
  ~StaticField() override;
  explicit PROTOBUF_CONSTEXPR StaticField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaticField(const StaticField& from);
  StaticField(StaticField&& from) noexcept
    : StaticField() {
    *this = ::std::move(from);
  }

  inline StaticField& operator=(const StaticField& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticField& operator=(StaticField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaticField& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaticField* internal_default_instance() {
    return reinterpret_cast<const StaticField*>(
               &_StaticField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StaticField& a, StaticField& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaticField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaticField& from) {
    StaticField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.StaticField";
  }
  protected:
  explicit StaticField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLvalueFieldNumber = 1,
    kConsFieldNumber = 2,
  };
  // required .joosc_fuzzer.Lvalue lvalue = 1;
  bool has_lvalue() const;
  private:
  bool _internal_has_lvalue() const;
  public:
  void clear_lvalue();
  const ::joosc_fuzzer::Lvalue& lvalue() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Lvalue* release_lvalue();
  ::joosc_fuzzer::Lvalue* mutable_lvalue();
  void set_allocated_lvalue(::joosc_fuzzer::Lvalue* lvalue);
  private:
  const ::joosc_fuzzer::Lvalue& _internal_lvalue() const;
  ::joosc_fuzzer::Lvalue* _internal_mutable_lvalue();
  public:
  void unsafe_arena_set_allocated_lvalue(
      ::joosc_fuzzer::Lvalue* lvalue);
  ::joosc_fuzzer::Lvalue* unsafe_arena_release_lvalue();

  // required .joosc_fuzzer.Const cons = 2;
  bool has_cons() const;
  private:
  bool _internal_has_cons() const;
  public:
  void clear_cons();
  const ::joosc_fuzzer::Const& cons() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::Const* release_cons();
  ::joosc_fuzzer::Const* mutable_cons();
  void set_allocated_cons(::joosc_fuzzer::Const* cons);
  private:
  const ::joosc_fuzzer::Const& _internal_cons() const;
  ::joosc_fuzzer::Const* _internal_mutable_cons();
  public:
  void unsafe_arena_set_allocated_cons(
      ::joosc_fuzzer::Const* cons);
  ::joosc_fuzzer::Const* unsafe_arena_release_cons();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.StaticField)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::joosc_fuzzer::Lvalue* lvalue_;
    ::joosc_fuzzer::Const* cons_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// -------------------------------------------------------------------

class Class final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:joosc_fuzzer.Class) */ {
 public:
  inline Class() : Class(nullptr) {}
  ~Class() override;
  explicit PROTOBUF_CONSTEXPR Class(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Class(const Class& from);
  Class(Class&& from) noexcept
    : Class() {
    *this = ::std::move(from);
  }

  inline Class& operator=(const Class& from) {
    CopyFrom(from);
    return *this;
  }
  inline Class& operator=(Class&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Class& default_instance() {
    return *internal_default_instance();
  }
  static inline const Class* internal_default_instance() {
    return reinterpret_cast<const Class*>(
               &_Class_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Class& a, Class& b) {
    a.Swap(&b);
  }
  inline void Swap(Class* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Class* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Class* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Class>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Class& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Class& from) {
    Class::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Class* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "joosc_fuzzer.Class";
  }
  protected:
  explicit Class(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kMethodsFieldNumber = 3,
    kMainBodyFieldNumber = 1,
  };
  // repeated .joosc_fuzzer.StaticField fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::joosc_fuzzer::StaticField* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StaticField >*
      mutable_fields();
  private:
  const ::joosc_fuzzer::StaticField& _internal_fields(int index) const;
  ::joosc_fuzzer::StaticField* _internal_add_fields();
  public:
  const ::joosc_fuzzer::StaticField& fields(int index) const;
  ::joosc_fuzzer::StaticField* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StaticField >&
      fields() const;

  // repeated .joosc_fuzzer.StatementSeq methods = 3;
  int methods_size() const;
  private:
  int _internal_methods_size() const;
  public:
  void clear_methods();
  ::joosc_fuzzer::StatementSeq* mutable_methods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StatementSeq >*
      mutable_methods();
  private:
  const ::joosc_fuzzer::StatementSeq& _internal_methods(int index) const;
  ::joosc_fuzzer::StatementSeq* _internal_add_methods();
  public:
  const ::joosc_fuzzer::StatementSeq& methods(int index) const;
  ::joosc_fuzzer::StatementSeq* add_methods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StatementSeq >&
      methods() const;

  // required .joosc_fuzzer.StatementSeq main_body = 1;
  bool has_main_body() const;
  private:
  bool _internal_has_main_body() const;
  public:
  void clear_main_body();
  const ::joosc_fuzzer::StatementSeq& main_body() const;
  PROTOBUF_NODISCARD ::joosc_fuzzer::StatementSeq* release_main_body();
  ::joosc_fuzzer::StatementSeq* mutable_main_body();
  void set_allocated_main_body(::joosc_fuzzer::StatementSeq* main_body);
  private:
  const ::joosc_fuzzer::StatementSeq& _internal_main_body() const;
  ::joosc_fuzzer::StatementSeq* _internal_mutable_main_body();
  public:
  void unsafe_arena_set_allocated_main_body(
      ::joosc_fuzzer::StatementSeq* main_body);
  ::joosc_fuzzer::StatementSeq* unsafe_arena_release_main_body();

  // @@protoc_insertion_point(class_scope:joosc_fuzzer.Class)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StaticField > fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StatementSeq > methods_;
    ::joosc_fuzzer::StatementSeq* main_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_joosc_5fproto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VarRef

// required int32 varnum = 1;
inline bool VarRef::_internal_has_varnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VarRef::has_varnum() const {
  return _internal_has_varnum();
}
inline void VarRef::clear_varnum() {
  _impl_.varnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VarRef::_internal_varnum() const {
  return _impl_.varnum_;
}
inline int32_t VarRef::varnum() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.VarRef.varnum)
  return _internal_varnum();
}
inline void VarRef::_internal_set_varnum(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.varnum_ = value;
}
inline void VarRef::set_varnum(int32_t value) {
  _internal_set_varnum(value);
  // @@protoc_insertion_point(field_set:joosc_fuzzer.VarRef.varnum)
}

// -------------------------------------------------------------------

// FunctionRef

// required int32 funcnum = 1;
inline bool FunctionRef::_internal_has_funcnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FunctionRef::has_funcnum() const {
  return _internal_has_funcnum();
}
inline void FunctionRef::clear_funcnum() {
  _impl_.funcnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t FunctionRef::_internal_funcnum() const {
  return _impl_.funcnum_;
}
inline int32_t FunctionRef::funcnum() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.FunctionRef.funcnum)
  return _internal_funcnum();
}
inline void FunctionRef::_internal_set_funcnum(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.funcnum_ = value;
}
inline void FunctionRef::set_funcnum(int32_t value) {
  _internal_set_funcnum(value);
  // @@protoc_insertion_point(field_set:joosc_fuzzer.FunctionRef.funcnum)
}

// -------------------------------------------------------------------

// Lvalue

// required .joosc_fuzzer.VarRef varref = 1;
inline bool Lvalue::_internal_has_varref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.varref_ != nullptr);
  return value;
}
inline bool Lvalue::has_varref() const {
  return _internal_has_varref();
}
inline void Lvalue::clear_varref() {
  if (_impl_.varref_ != nullptr) _impl_.varref_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::VarRef& Lvalue::_internal_varref() const {
  const ::joosc_fuzzer::VarRef* p = _impl_.varref_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::VarRef&>(
      ::joosc_fuzzer::_VarRef_default_instance_);
}
inline const ::joosc_fuzzer::VarRef& Lvalue::varref() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Lvalue.varref)
  return _internal_varref();
}
inline void Lvalue::unsafe_arena_set_allocated_varref(
    ::joosc_fuzzer::VarRef* varref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varref_);
  }
  _impl_.varref_ = varref;
  if (varref) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Lvalue.varref)
}
inline ::joosc_fuzzer::VarRef* Lvalue::release_varref() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::VarRef* temp = _impl_.varref_;
  _impl_.varref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::VarRef* Lvalue::unsafe_arena_release_varref() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Lvalue.varref)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::VarRef* temp = _impl_.varref_;
  _impl_.varref_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::VarRef* Lvalue::_internal_mutable_varref() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.varref_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::VarRef>(GetArenaForAllocation());
    _impl_.varref_ = p;
  }
  return _impl_.varref_;
}
inline ::joosc_fuzzer::VarRef* Lvalue::mutable_varref() {
  ::joosc_fuzzer::VarRef* _msg = _internal_mutable_varref();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Lvalue.varref)
  return _msg;
}
inline void Lvalue::set_allocated_varref(::joosc_fuzzer::VarRef* varref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.varref_;
  }
  if (varref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varref);
    if (message_arena != submessage_arena) {
      varref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varref, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.varref_ = varref;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Lvalue.varref)
}

// -------------------------------------------------------------------

// Rvalue

// .joosc_fuzzer.VarRef varref = 1;
inline bool Rvalue::_internal_has_varref() const {
  return rvalue_oneof_case() == kVarref;
}
inline bool Rvalue::has_varref() const {
  return _internal_has_varref();
}
inline void Rvalue::set_has_varref() {
  _impl_._oneof_case_[0] = kVarref;
}
inline void Rvalue::clear_varref() {
  if (_internal_has_varref()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.rvalue_oneof_.varref_;
    }
    clear_has_rvalue_oneof();
  }
}
inline ::joosc_fuzzer::VarRef* Rvalue::release_varref() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Rvalue.varref)
  if (_internal_has_varref()) {
    clear_has_rvalue_oneof();
    ::joosc_fuzzer::VarRef* temp = _impl_.rvalue_oneof_.varref_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rvalue_oneof_.varref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::VarRef& Rvalue::_internal_varref() const {
  return _internal_has_varref()
      ? *_impl_.rvalue_oneof_.varref_
      : reinterpret_cast< ::joosc_fuzzer::VarRef&>(::joosc_fuzzer::_VarRef_default_instance_);
}
inline const ::joosc_fuzzer::VarRef& Rvalue::varref() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Rvalue.varref)
  return _internal_varref();
}
inline ::joosc_fuzzer::VarRef* Rvalue::unsafe_arena_release_varref() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.Rvalue.varref)
  if (_internal_has_varref()) {
    clear_has_rvalue_oneof();
    ::joosc_fuzzer::VarRef* temp = _impl_.rvalue_oneof_.varref_;
    _impl_.rvalue_oneof_.varref_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rvalue::unsafe_arena_set_allocated_varref(::joosc_fuzzer::VarRef* varref) {
  clear_rvalue_oneof();
  if (varref) {
    set_has_varref();
    _impl_.rvalue_oneof_.varref_ = varref;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Rvalue.varref)
}
inline ::joosc_fuzzer::VarRef* Rvalue::_internal_mutable_varref() {
  if (!_internal_has_varref()) {
    clear_rvalue_oneof();
    set_has_varref();
    _impl_.rvalue_oneof_.varref_ = CreateMaybeMessage< ::joosc_fuzzer::VarRef >(GetArenaForAllocation());
  }
  return _impl_.rvalue_oneof_.varref_;
}
inline ::joosc_fuzzer::VarRef* Rvalue::mutable_varref() {
  ::joosc_fuzzer::VarRef* _msg = _internal_mutable_varref();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Rvalue.varref)
  return _msg;
}

// .joosc_fuzzer.BinaryOp binop = 2;
inline bool Rvalue::_internal_has_binop() const {
  return rvalue_oneof_case() == kBinop;
}
inline bool Rvalue::has_binop() const {
  return _internal_has_binop();
}
inline void Rvalue::set_has_binop() {
  _impl_._oneof_case_[0] = kBinop;
}
inline void Rvalue::clear_binop() {
  if (_internal_has_binop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.rvalue_oneof_.binop_;
    }
    clear_has_rvalue_oneof();
  }
}
inline ::joosc_fuzzer::BinaryOp* Rvalue::release_binop() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Rvalue.binop)
  if (_internal_has_binop()) {
    clear_has_rvalue_oneof();
    ::joosc_fuzzer::BinaryOp* temp = _impl_.rvalue_oneof_.binop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rvalue_oneof_.binop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::BinaryOp& Rvalue::_internal_binop() const {
  return _internal_has_binop()
      ? *_impl_.rvalue_oneof_.binop_
      : reinterpret_cast< ::joosc_fuzzer::BinaryOp&>(::joosc_fuzzer::_BinaryOp_default_instance_);
}
inline const ::joosc_fuzzer::BinaryOp& Rvalue::binop() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Rvalue.binop)
  return _internal_binop();
}
inline ::joosc_fuzzer::BinaryOp* Rvalue::unsafe_arena_release_binop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.Rvalue.binop)
  if (_internal_has_binop()) {
    clear_has_rvalue_oneof();
    ::joosc_fuzzer::BinaryOp* temp = _impl_.rvalue_oneof_.binop_;
    _impl_.rvalue_oneof_.binop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rvalue::unsafe_arena_set_allocated_binop(::joosc_fuzzer::BinaryOp* binop) {
  clear_rvalue_oneof();
  if (binop) {
    set_has_binop();
    _impl_.rvalue_oneof_.binop_ = binop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Rvalue.binop)
}
inline ::joosc_fuzzer::BinaryOp* Rvalue::_internal_mutable_binop() {
  if (!_internal_has_binop()) {
    clear_rvalue_oneof();
    set_has_binop();
    _impl_.rvalue_oneof_.binop_ = CreateMaybeMessage< ::joosc_fuzzer::BinaryOp >(GetArenaForAllocation());
  }
  return _impl_.rvalue_oneof_.binop_;
}
inline ::joosc_fuzzer::BinaryOp* Rvalue::mutable_binop() {
  ::joosc_fuzzer::BinaryOp* _msg = _internal_mutable_binop();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Rvalue.binop)
  return _msg;
}

// required .joosc_fuzzer.Const cons = 3;
inline bool Rvalue::_internal_has_cons() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cons_ != nullptr);
  return value;
}
inline bool Rvalue::has_cons() const {
  return _internal_has_cons();
}
inline void Rvalue::clear_cons() {
  if (_impl_.cons_ != nullptr) _impl_.cons_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::Const& Rvalue::_internal_cons() const {
  const ::joosc_fuzzer::Const* p = _impl_.cons_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Const&>(
      ::joosc_fuzzer::_Const_default_instance_);
}
inline const ::joosc_fuzzer::Const& Rvalue::cons() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Rvalue.cons)
  return _internal_cons();
}
inline void Rvalue::unsafe_arena_set_allocated_cons(
    ::joosc_fuzzer::Const* cons) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cons_);
  }
  _impl_.cons_ = cons;
  if (cons) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Rvalue.cons)
}
inline ::joosc_fuzzer::Const* Rvalue::release_cons() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Const* temp = _impl_.cons_;
  _impl_.cons_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Const* Rvalue::unsafe_arena_release_cons() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Rvalue.cons)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Const* temp = _impl_.cons_;
  _impl_.cons_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Const* Rvalue::_internal_mutable_cons() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cons_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Const>(GetArenaForAllocation());
    _impl_.cons_ = p;
  }
  return _impl_.cons_;
}
inline ::joosc_fuzzer::Const* Rvalue::mutable_cons() {
  ::joosc_fuzzer::Const* _msg = _internal_mutable_cons();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Rvalue.cons)
  return _msg;
}
inline void Rvalue::set_allocated_cons(::joosc_fuzzer::Const* cons) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cons_;
  }
  if (cons) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cons);
    if (message_arena != submessage_arena) {
      cons = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cons, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cons_ = cons;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Rvalue.cons)
}

inline bool Rvalue::has_rvalue_oneof() const {
  return rvalue_oneof_case() != RVALUE_ONEOF_NOT_SET;
}
inline void Rvalue::clear_has_rvalue_oneof() {
  _impl_._oneof_case_[0] = RVALUE_ONEOF_NOT_SET;
}
inline Rvalue::RvalueOneofCase Rvalue::rvalue_oneof_case() const {
  return Rvalue::RvalueOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Const

// required int32 val = 1;
inline bool Const::_internal_has_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Const::has_val() const {
  return _internal_has_val();
}
inline void Const::clear_val() {
  _impl_.val_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Const::_internal_val() const {
  return _impl_.val_;
}
inline int32_t Const::val() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Const.val)
  return _internal_val();
}
inline void Const::_internal_set_val(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.val_ = value;
}
inline void Const::set_val(int32_t value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:joosc_fuzzer.Const.val)
}

// -------------------------------------------------------------------

// BinaryOp

// required .joosc_fuzzer.BinaryOp.Op op = 1;
inline bool BinaryOp::_internal_has_op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BinaryOp::has_op() const {
  return _internal_has_op();
}
inline void BinaryOp::clear_op() {
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::joosc_fuzzer::BinaryOp_Op BinaryOp::_internal_op() const {
  return static_cast< ::joosc_fuzzer::BinaryOp_Op >(_impl_.op_);
}
inline ::joosc_fuzzer::BinaryOp_Op BinaryOp::op() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BinaryOp.op)
  return _internal_op();
}
inline void BinaryOp::_internal_set_op(::joosc_fuzzer::BinaryOp_Op value) {
  assert(::joosc_fuzzer::BinaryOp_Op_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.op_ = value;
}
inline void BinaryOp::set_op(::joosc_fuzzer::BinaryOp_Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:joosc_fuzzer.BinaryOp.op)
}

// required .joosc_fuzzer.Rvalue left = 2;
inline bool BinaryOp::_internal_has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline bool BinaryOp::has_left() const {
  return _internal_has_left();
}
inline void BinaryOp::clear_left() {
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::Rvalue& BinaryOp::_internal_left() const {
  const ::joosc_fuzzer::Rvalue* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Rvalue&>(
      ::joosc_fuzzer::_Rvalue_default_instance_);
}
inline const ::joosc_fuzzer::Rvalue& BinaryOp::left() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BinaryOp.left)
  return _internal_left();
}
inline void BinaryOp::unsafe_arena_set_allocated_left(
    ::joosc_fuzzer::Rvalue* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.BinaryOp.left)
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::release_left() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.BinaryOp.left)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::_internal_mutable_left() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Rvalue>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::mutable_left() {
  ::joosc_fuzzer::Rvalue* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.BinaryOp.left)
  return _msg;
}
inline void BinaryOp::set_allocated_left(::joosc_fuzzer::Rvalue* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.BinaryOp.left)
}

// required .joosc_fuzzer.Rvalue right = 3;
inline bool BinaryOp::_internal_has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline bool BinaryOp::has_right() const {
  return _internal_has_right();
}
inline void BinaryOp::clear_right() {
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::Rvalue& BinaryOp::_internal_right() const {
  const ::joosc_fuzzer::Rvalue* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Rvalue&>(
      ::joosc_fuzzer::_Rvalue_default_instance_);
}
inline const ::joosc_fuzzer::Rvalue& BinaryOp::right() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BinaryOp.right)
  return _internal_right();
}
inline void BinaryOp::unsafe_arena_set_allocated_right(
    ::joosc_fuzzer::Rvalue* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = right;
  if (right) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.BinaryOp.right)
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::release_right() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.BinaryOp.right)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::_internal_mutable_right() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Rvalue>(GetArenaForAllocation());
    _impl_.right_ = p;
  }
  return _impl_.right_;
}
inline ::joosc_fuzzer::Rvalue* BinaryOp::mutable_right() {
  ::joosc_fuzzer::Rvalue* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.BinaryOp.right)
  return _msg;
}
inline void BinaryOp::set_allocated_right(::joosc_fuzzer::Rvalue* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.right_ = right;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.BinaryOp.right)
}

// -------------------------------------------------------------------

// BoolRvalue

// .joosc_fuzzer.BoolToBoolOp boolop = 1;
inline bool BoolRvalue::_internal_has_boolop() const {
  return bool_binop_oneof_case() == kBoolop;
}
inline bool BoolRvalue::has_boolop() const {
  return _internal_has_boolop();
}
inline void BoolRvalue::set_has_boolop() {
  _impl_._oneof_case_[0] = kBoolop;
}
inline void BoolRvalue::clear_boolop() {
  if (_internal_has_boolop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.bool_binop_oneof_.boolop_;
    }
    clear_has_bool_binop_oneof();
  }
}
inline ::joosc_fuzzer::BoolToBoolOp* BoolRvalue::release_boolop() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.BoolRvalue.boolop)
  if (_internal_has_boolop()) {
    clear_has_bool_binop_oneof();
    ::joosc_fuzzer::BoolToBoolOp* temp = _impl_.bool_binop_oneof_.boolop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.bool_binop_oneof_.boolop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::BoolToBoolOp& BoolRvalue::_internal_boolop() const {
  return _internal_has_boolop()
      ? *_impl_.bool_binop_oneof_.boolop_
      : reinterpret_cast< ::joosc_fuzzer::BoolToBoolOp&>(::joosc_fuzzer::_BoolToBoolOp_default_instance_);
}
inline const ::joosc_fuzzer::BoolToBoolOp& BoolRvalue::boolop() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BoolRvalue.boolop)
  return _internal_boolop();
}
inline ::joosc_fuzzer::BoolToBoolOp* BoolRvalue::unsafe_arena_release_boolop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.BoolRvalue.boolop)
  if (_internal_has_boolop()) {
    clear_has_bool_binop_oneof();
    ::joosc_fuzzer::BoolToBoolOp* temp = _impl_.bool_binop_oneof_.boolop_;
    _impl_.bool_binop_oneof_.boolop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BoolRvalue::unsafe_arena_set_allocated_boolop(::joosc_fuzzer::BoolToBoolOp* boolop) {
  clear_bool_binop_oneof();
  if (boolop) {
    set_has_boolop();
    _impl_.bool_binop_oneof_.boolop_ = boolop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.BoolRvalue.boolop)
}
inline ::joosc_fuzzer::BoolToBoolOp* BoolRvalue::_internal_mutable_boolop() {
  if (!_internal_has_boolop()) {
    clear_bool_binop_oneof();
    set_has_boolop();
    _impl_.bool_binop_oneof_.boolop_ = CreateMaybeMessage< ::joosc_fuzzer::BoolToBoolOp >(GetArenaForAllocation());
  }
  return _impl_.bool_binop_oneof_.boolop_;
}
inline ::joosc_fuzzer::BoolToBoolOp* BoolRvalue::mutable_boolop() {
  ::joosc_fuzzer::BoolToBoolOp* _msg = _internal_mutable_boolop();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.BoolRvalue.boolop)
  return _msg;
}

// .joosc_fuzzer.IntToBoolOp intop = 2;
inline bool BoolRvalue::_internal_has_intop() const {
  return bool_binop_oneof_case() == kIntop;
}
inline bool BoolRvalue::has_intop() const {
  return _internal_has_intop();
}
inline void BoolRvalue::set_has_intop() {
  _impl_._oneof_case_[0] = kIntop;
}
inline void BoolRvalue::clear_intop() {
  if (_internal_has_intop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.bool_binop_oneof_.intop_;
    }
    clear_has_bool_binop_oneof();
  }
}
inline ::joosc_fuzzer::IntToBoolOp* BoolRvalue::release_intop() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.BoolRvalue.intop)
  if (_internal_has_intop()) {
    clear_has_bool_binop_oneof();
    ::joosc_fuzzer::IntToBoolOp* temp = _impl_.bool_binop_oneof_.intop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.bool_binop_oneof_.intop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::IntToBoolOp& BoolRvalue::_internal_intop() const {
  return _internal_has_intop()
      ? *_impl_.bool_binop_oneof_.intop_
      : reinterpret_cast< ::joosc_fuzzer::IntToBoolOp&>(::joosc_fuzzer::_IntToBoolOp_default_instance_);
}
inline const ::joosc_fuzzer::IntToBoolOp& BoolRvalue::intop() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BoolRvalue.intop)
  return _internal_intop();
}
inline ::joosc_fuzzer::IntToBoolOp* BoolRvalue::unsafe_arena_release_intop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.BoolRvalue.intop)
  if (_internal_has_intop()) {
    clear_has_bool_binop_oneof();
    ::joosc_fuzzer::IntToBoolOp* temp = _impl_.bool_binop_oneof_.intop_;
    _impl_.bool_binop_oneof_.intop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BoolRvalue::unsafe_arena_set_allocated_intop(::joosc_fuzzer::IntToBoolOp* intop) {
  clear_bool_binop_oneof();
  if (intop) {
    set_has_intop();
    _impl_.bool_binop_oneof_.intop_ = intop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.BoolRvalue.intop)
}
inline ::joosc_fuzzer::IntToBoolOp* BoolRvalue::_internal_mutable_intop() {
  if (!_internal_has_intop()) {
    clear_bool_binop_oneof();
    set_has_intop();
    _impl_.bool_binop_oneof_.intop_ = CreateMaybeMessage< ::joosc_fuzzer::IntToBoolOp >(GetArenaForAllocation());
  }
  return _impl_.bool_binop_oneof_.intop_;
}
inline ::joosc_fuzzer::IntToBoolOp* BoolRvalue::mutable_intop() {
  ::joosc_fuzzer::IntToBoolOp* _msg = _internal_mutable_intop();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.BoolRvalue.intop)
  return _msg;
}

// required bool cons = 3;
inline bool BoolRvalue::_internal_has_cons() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BoolRvalue::has_cons() const {
  return _internal_has_cons();
}
inline void BoolRvalue::clear_cons() {
  _impl_.cons_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BoolRvalue::_internal_cons() const {
  return _impl_.cons_;
}
inline bool BoolRvalue::cons() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BoolRvalue.cons)
  return _internal_cons();
}
inline void BoolRvalue::_internal_set_cons(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cons_ = value;
}
inline void BoolRvalue::set_cons(bool value) {
  _internal_set_cons(value);
  // @@protoc_insertion_point(field_set:joosc_fuzzer.BoolRvalue.cons)
}

inline bool BoolRvalue::has_bool_binop_oneof() const {
  return bool_binop_oneof_case() != BOOL_BINOP_ONEOF_NOT_SET;
}
inline void BoolRvalue::clear_has_bool_binop_oneof() {
  _impl_._oneof_case_[0] = BOOL_BINOP_ONEOF_NOT_SET;
}
inline BoolRvalue::BoolBinopOneofCase BoolRvalue::bool_binop_oneof_case() const {
  return BoolRvalue::BoolBinopOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BoolToBoolOp

// required .joosc_fuzzer.BoolToBoolOp.Op op = 1;
inline bool BoolToBoolOp::_internal_has_op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BoolToBoolOp::has_op() const {
  return _internal_has_op();
}
inline void BoolToBoolOp::clear_op() {
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::joosc_fuzzer::BoolToBoolOp_Op BoolToBoolOp::_internal_op() const {
  return static_cast< ::joosc_fuzzer::BoolToBoolOp_Op >(_impl_.op_);
}
inline ::joosc_fuzzer::BoolToBoolOp_Op BoolToBoolOp::op() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BoolToBoolOp.op)
  return _internal_op();
}
inline void BoolToBoolOp::_internal_set_op(::joosc_fuzzer::BoolToBoolOp_Op value) {
  assert(::joosc_fuzzer::BoolToBoolOp_Op_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.op_ = value;
}
inline void BoolToBoolOp::set_op(::joosc_fuzzer::BoolToBoolOp_Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:joosc_fuzzer.BoolToBoolOp.op)
}

// required .joosc_fuzzer.BoolRvalue left = 2;
inline bool BoolToBoolOp::_internal_has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline bool BoolToBoolOp::has_left() const {
  return _internal_has_left();
}
inline void BoolToBoolOp::clear_left() {
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::BoolRvalue& BoolToBoolOp::_internal_left() const {
  const ::joosc_fuzzer::BoolRvalue* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::BoolRvalue&>(
      ::joosc_fuzzer::_BoolRvalue_default_instance_);
}
inline const ::joosc_fuzzer::BoolRvalue& BoolToBoolOp::left() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BoolToBoolOp.left)
  return _internal_left();
}
inline void BoolToBoolOp::unsafe_arena_set_allocated_left(
    ::joosc_fuzzer::BoolRvalue* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.BoolToBoolOp.left)
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::release_left() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.BoolToBoolOp.left)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::_internal_mutable_left() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::BoolRvalue>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::mutable_left() {
  ::joosc_fuzzer::BoolRvalue* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.BoolToBoolOp.left)
  return _msg;
}
inline void BoolToBoolOp::set_allocated_left(::joosc_fuzzer::BoolRvalue* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.BoolToBoolOp.left)
}

// required .joosc_fuzzer.BoolRvalue right = 3;
inline bool BoolToBoolOp::_internal_has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline bool BoolToBoolOp::has_right() const {
  return _internal_has_right();
}
inline void BoolToBoolOp::clear_right() {
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::BoolRvalue& BoolToBoolOp::_internal_right() const {
  const ::joosc_fuzzer::BoolRvalue* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::BoolRvalue&>(
      ::joosc_fuzzer::_BoolRvalue_default_instance_);
}
inline const ::joosc_fuzzer::BoolRvalue& BoolToBoolOp::right() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.BoolToBoolOp.right)
  return _internal_right();
}
inline void BoolToBoolOp::unsafe_arena_set_allocated_right(
    ::joosc_fuzzer::BoolRvalue* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = right;
  if (right) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.BoolToBoolOp.right)
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::release_right() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.BoolToBoolOp.right)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::_internal_mutable_right() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::BoolRvalue>(GetArenaForAllocation());
    _impl_.right_ = p;
  }
  return _impl_.right_;
}
inline ::joosc_fuzzer::BoolRvalue* BoolToBoolOp::mutable_right() {
  ::joosc_fuzzer::BoolRvalue* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.BoolToBoolOp.right)
  return _msg;
}
inline void BoolToBoolOp::set_allocated_right(::joosc_fuzzer::BoolRvalue* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.right_ = right;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.BoolToBoolOp.right)
}

// -------------------------------------------------------------------

// IntToBoolOp

// required .joosc_fuzzer.IntToBoolOp.Op op = 1;
inline bool IntToBoolOp::_internal_has_op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IntToBoolOp::has_op() const {
  return _internal_has_op();
}
inline void IntToBoolOp::clear_op() {
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::joosc_fuzzer::IntToBoolOp_Op IntToBoolOp::_internal_op() const {
  return static_cast< ::joosc_fuzzer::IntToBoolOp_Op >(_impl_.op_);
}
inline ::joosc_fuzzer::IntToBoolOp_Op IntToBoolOp::op() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IntToBoolOp.op)
  return _internal_op();
}
inline void IntToBoolOp::_internal_set_op(::joosc_fuzzer::IntToBoolOp_Op value) {
  assert(::joosc_fuzzer::IntToBoolOp_Op_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.op_ = value;
}
inline void IntToBoolOp::set_op(::joosc_fuzzer::IntToBoolOp_Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:joosc_fuzzer.IntToBoolOp.op)
}

// required .joosc_fuzzer.Rvalue left = 2;
inline bool IntToBoolOp::_internal_has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline bool IntToBoolOp::has_left() const {
  return _internal_has_left();
}
inline void IntToBoolOp::clear_left() {
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::Rvalue& IntToBoolOp::_internal_left() const {
  const ::joosc_fuzzer::Rvalue* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Rvalue&>(
      ::joosc_fuzzer::_Rvalue_default_instance_);
}
inline const ::joosc_fuzzer::Rvalue& IntToBoolOp::left() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IntToBoolOp.left)
  return _internal_left();
}
inline void IntToBoolOp::unsafe_arena_set_allocated_left(
    ::joosc_fuzzer::Rvalue* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.IntToBoolOp.left)
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::release_left() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.IntToBoolOp.left)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::_internal_mutable_left() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Rvalue>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::mutable_left() {
  ::joosc_fuzzer::Rvalue* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.IntToBoolOp.left)
  return _msg;
}
inline void IntToBoolOp::set_allocated_left(::joosc_fuzzer::Rvalue* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.IntToBoolOp.left)
}

// required .joosc_fuzzer.Rvalue right = 3;
inline bool IntToBoolOp::_internal_has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline bool IntToBoolOp::has_right() const {
  return _internal_has_right();
}
inline void IntToBoolOp::clear_right() {
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::Rvalue& IntToBoolOp::_internal_right() const {
  const ::joosc_fuzzer::Rvalue* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Rvalue&>(
      ::joosc_fuzzer::_Rvalue_default_instance_);
}
inline const ::joosc_fuzzer::Rvalue& IntToBoolOp::right() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IntToBoolOp.right)
  return _internal_right();
}
inline void IntToBoolOp::unsafe_arena_set_allocated_right(
    ::joosc_fuzzer::Rvalue* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = right;
  if (right) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.IntToBoolOp.right)
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::release_right() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.IntToBoolOp.right)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::_internal_mutable_right() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Rvalue>(GetArenaForAllocation());
    _impl_.right_ = p;
  }
  return _impl_.right_;
}
inline ::joosc_fuzzer::Rvalue* IntToBoolOp::mutable_right() {
  ::joosc_fuzzer::Rvalue* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.IntToBoolOp.right)
  return _msg;
}
inline void IntToBoolOp::set_allocated_right(::joosc_fuzzer::Rvalue* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.right_ = right;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.IntToBoolOp.right)
}

// -------------------------------------------------------------------

// AssignmentStatement

// required .joosc_fuzzer.Lvalue lvalue = 1;
inline bool AssignmentStatement::_internal_has_lvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lvalue_ != nullptr);
  return value;
}
inline bool AssignmentStatement::has_lvalue() const {
  return _internal_has_lvalue();
}
inline void AssignmentStatement::clear_lvalue() {
  if (_impl_.lvalue_ != nullptr) _impl_.lvalue_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::Lvalue& AssignmentStatement::_internal_lvalue() const {
  const ::joosc_fuzzer::Lvalue* p = _impl_.lvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Lvalue&>(
      ::joosc_fuzzer::_Lvalue_default_instance_);
}
inline const ::joosc_fuzzer::Lvalue& AssignmentStatement::lvalue() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.AssignmentStatement.lvalue)
  return _internal_lvalue();
}
inline void AssignmentStatement::unsafe_arena_set_allocated_lvalue(
    ::joosc_fuzzer::Lvalue* lvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lvalue_);
  }
  _impl_.lvalue_ = lvalue;
  if (lvalue) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.AssignmentStatement.lvalue)
}
inline ::joosc_fuzzer::Lvalue* AssignmentStatement::release_lvalue() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Lvalue* temp = _impl_.lvalue_;
  _impl_.lvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Lvalue* AssignmentStatement::unsafe_arena_release_lvalue() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.AssignmentStatement.lvalue)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Lvalue* temp = _impl_.lvalue_;
  _impl_.lvalue_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Lvalue* AssignmentStatement::_internal_mutable_lvalue() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Lvalue>(GetArenaForAllocation());
    _impl_.lvalue_ = p;
  }
  return _impl_.lvalue_;
}
inline ::joosc_fuzzer::Lvalue* AssignmentStatement::mutable_lvalue() {
  ::joosc_fuzzer::Lvalue* _msg = _internal_mutable_lvalue();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.AssignmentStatement.lvalue)
  return _msg;
}
inline void AssignmentStatement::set_allocated_lvalue(::joosc_fuzzer::Lvalue* lvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lvalue_;
  }
  if (lvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lvalue);
    if (message_arena != submessage_arena) {
      lvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lvalue, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lvalue_ = lvalue;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.AssignmentStatement.lvalue)
}

// required .joosc_fuzzer.Rvalue rvalue = 2;
inline bool AssignmentStatement::_internal_has_rvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rvalue_ != nullptr);
  return value;
}
inline bool AssignmentStatement::has_rvalue() const {
  return _internal_has_rvalue();
}
inline void AssignmentStatement::clear_rvalue() {
  if (_impl_.rvalue_ != nullptr) _impl_.rvalue_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::Rvalue& AssignmentStatement::_internal_rvalue() const {
  const ::joosc_fuzzer::Rvalue* p = _impl_.rvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Rvalue&>(
      ::joosc_fuzzer::_Rvalue_default_instance_);
}
inline const ::joosc_fuzzer::Rvalue& AssignmentStatement::rvalue() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.AssignmentStatement.rvalue)
  return _internal_rvalue();
}
inline void AssignmentStatement::unsafe_arena_set_allocated_rvalue(
    ::joosc_fuzzer::Rvalue* rvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rvalue_);
  }
  _impl_.rvalue_ = rvalue;
  if (rvalue) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.AssignmentStatement.rvalue)
}
inline ::joosc_fuzzer::Rvalue* AssignmentStatement::release_rvalue() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.rvalue_;
  _impl_.rvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Rvalue* AssignmentStatement::unsafe_arena_release_rvalue() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.AssignmentStatement.rvalue)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Rvalue* temp = _impl_.rvalue_;
  _impl_.rvalue_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Rvalue* AssignmentStatement::_internal_mutable_rvalue() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Rvalue>(GetArenaForAllocation());
    _impl_.rvalue_ = p;
  }
  return _impl_.rvalue_;
}
inline ::joosc_fuzzer::Rvalue* AssignmentStatement::mutable_rvalue() {
  ::joosc_fuzzer::Rvalue* _msg = _internal_mutable_rvalue();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.AssignmentStatement.rvalue)
  return _msg;
}
inline void AssignmentStatement::set_allocated_rvalue(::joosc_fuzzer::Rvalue* rvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rvalue_;
  }
  if (rvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rvalue);
    if (message_arena != submessage_arena) {
      rvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rvalue, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rvalue_ = rvalue;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.AssignmentStatement.rvalue)
}

// -------------------------------------------------------------------

// MethodInvocation

// required .joosc_fuzzer.FunctionRef funcref = 1;
inline bool MethodInvocation::_internal_has_funcref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.funcref_ != nullptr);
  return value;
}
inline bool MethodInvocation::has_funcref() const {
  return _internal_has_funcref();
}
inline void MethodInvocation::clear_funcref() {
  if (_impl_.funcref_ != nullptr) _impl_.funcref_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::FunctionRef& MethodInvocation::_internal_funcref() const {
  const ::joosc_fuzzer::FunctionRef* p = _impl_.funcref_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::FunctionRef&>(
      ::joosc_fuzzer::_FunctionRef_default_instance_);
}
inline const ::joosc_fuzzer::FunctionRef& MethodInvocation::funcref() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.MethodInvocation.funcref)
  return _internal_funcref();
}
inline void MethodInvocation::unsafe_arena_set_allocated_funcref(
    ::joosc_fuzzer::FunctionRef* funcref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funcref_);
  }
  _impl_.funcref_ = funcref;
  if (funcref) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.MethodInvocation.funcref)
}
inline ::joosc_fuzzer::FunctionRef* MethodInvocation::release_funcref() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::FunctionRef* temp = _impl_.funcref_;
  _impl_.funcref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::FunctionRef* MethodInvocation::unsafe_arena_release_funcref() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.MethodInvocation.funcref)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::FunctionRef* temp = _impl_.funcref_;
  _impl_.funcref_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::FunctionRef* MethodInvocation::_internal_mutable_funcref() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.funcref_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::FunctionRef>(GetArenaForAllocation());
    _impl_.funcref_ = p;
  }
  return _impl_.funcref_;
}
inline ::joosc_fuzzer::FunctionRef* MethodInvocation::mutable_funcref() {
  ::joosc_fuzzer::FunctionRef* _msg = _internal_mutable_funcref();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.MethodInvocation.funcref)
  return _msg;
}
inline void MethodInvocation::set_allocated_funcref(::joosc_fuzzer::FunctionRef* funcref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.funcref_;
  }
  if (funcref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(funcref);
    if (message_arena != submessage_arena) {
      funcref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, funcref, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.funcref_ = funcref;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.MethodInvocation.funcref)
}

// -------------------------------------------------------------------

// MethodInvocationStatement

// required .joosc_fuzzer.MethodInvocation method_invocation = 1;
inline bool MethodInvocationStatement::_internal_has_method_invocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.method_invocation_ != nullptr);
  return value;
}
inline bool MethodInvocationStatement::has_method_invocation() const {
  return _internal_has_method_invocation();
}
inline void MethodInvocationStatement::clear_method_invocation() {
  if (_impl_.method_invocation_ != nullptr) _impl_.method_invocation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::MethodInvocation& MethodInvocationStatement::_internal_method_invocation() const {
  const ::joosc_fuzzer::MethodInvocation* p = _impl_.method_invocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::MethodInvocation&>(
      ::joosc_fuzzer::_MethodInvocation_default_instance_);
}
inline const ::joosc_fuzzer::MethodInvocation& MethodInvocationStatement::method_invocation() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.MethodInvocationStatement.method_invocation)
  return _internal_method_invocation();
}
inline void MethodInvocationStatement::unsafe_arena_set_allocated_method_invocation(
    ::joosc_fuzzer::MethodInvocation* method_invocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.method_invocation_);
  }
  _impl_.method_invocation_ = method_invocation;
  if (method_invocation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.MethodInvocationStatement.method_invocation)
}
inline ::joosc_fuzzer::MethodInvocation* MethodInvocationStatement::release_method_invocation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::MethodInvocation* temp = _impl_.method_invocation_;
  _impl_.method_invocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::MethodInvocation* MethodInvocationStatement::unsafe_arena_release_method_invocation() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.MethodInvocationStatement.method_invocation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::MethodInvocation* temp = _impl_.method_invocation_;
  _impl_.method_invocation_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::MethodInvocation* MethodInvocationStatement::_internal_mutable_method_invocation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.method_invocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::MethodInvocation>(GetArenaForAllocation());
    _impl_.method_invocation_ = p;
  }
  return _impl_.method_invocation_;
}
inline ::joosc_fuzzer::MethodInvocation* MethodInvocationStatement::mutable_method_invocation() {
  ::joosc_fuzzer::MethodInvocation* _msg = _internal_mutable_method_invocation();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.MethodInvocationStatement.method_invocation)
  return _msg;
}
inline void MethodInvocationStatement::set_allocated_method_invocation(::joosc_fuzzer::MethodInvocation* method_invocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.method_invocation_;
  }
  if (method_invocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(method_invocation);
    if (message_arena != submessage_arena) {
      method_invocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, method_invocation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.method_invocation_ = method_invocation;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.MethodInvocationStatement.method_invocation)
}

// -------------------------------------------------------------------

// IfThen

// required .joosc_fuzzer.BoolRvalue cond = 1;
inline bool IfThen::_internal_has_cond() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cond_ != nullptr);
  return value;
}
inline bool IfThen::has_cond() const {
  return _internal_has_cond();
}
inline void IfThen::clear_cond() {
  if (_impl_.cond_ != nullptr) _impl_.cond_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::BoolRvalue& IfThen::_internal_cond() const {
  const ::joosc_fuzzer::BoolRvalue* p = _impl_.cond_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::BoolRvalue&>(
      ::joosc_fuzzer::_BoolRvalue_default_instance_);
}
inline const ::joosc_fuzzer::BoolRvalue& IfThen::cond() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IfThen.cond)
  return _internal_cond();
}
inline void IfThen::unsafe_arena_set_allocated_cond(
    ::joosc_fuzzer::BoolRvalue* cond) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cond_);
  }
  _impl_.cond_ = cond;
  if (cond) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.IfThen.cond)
}
inline ::joosc_fuzzer::BoolRvalue* IfThen::release_cond() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.cond_;
  _impl_.cond_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* IfThen::unsafe_arena_release_cond() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.IfThen.cond)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.cond_;
  _impl_.cond_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* IfThen::_internal_mutable_cond() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cond_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::BoolRvalue>(GetArenaForAllocation());
    _impl_.cond_ = p;
  }
  return _impl_.cond_;
}
inline ::joosc_fuzzer::BoolRvalue* IfThen::mutable_cond() {
  ::joosc_fuzzer::BoolRvalue* _msg = _internal_mutable_cond();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.IfThen.cond)
  return _msg;
}
inline void IfThen::set_allocated_cond(::joosc_fuzzer::BoolRvalue* cond) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cond_;
  }
  if (cond) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cond);
    if (message_arena != submessage_arena) {
      cond = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.IfThen.cond)
}

// required .joosc_fuzzer.StatementSeq if_body = 2;
inline bool IfThen::_internal_has_if_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.if_body_ != nullptr);
  return value;
}
inline bool IfThen::has_if_body() const {
  return _internal_has_if_body();
}
inline void IfThen::clear_if_body() {
  if (_impl_.if_body_ != nullptr) _impl_.if_body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::StatementSeq& IfThen::_internal_if_body() const {
  const ::joosc_fuzzer::StatementSeq* p = _impl_.if_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::StatementSeq&>(
      ::joosc_fuzzer::_StatementSeq_default_instance_);
}
inline const ::joosc_fuzzer::StatementSeq& IfThen::if_body() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IfThen.if_body)
  return _internal_if_body();
}
inline void IfThen::unsafe_arena_set_allocated_if_body(
    ::joosc_fuzzer::StatementSeq* if_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.if_body_);
  }
  _impl_.if_body_ = if_body;
  if (if_body) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.IfThen.if_body)
}
inline ::joosc_fuzzer::StatementSeq* IfThen::release_if_body() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.if_body_;
  _impl_.if_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* IfThen::unsafe_arena_release_if_body() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.IfThen.if_body)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.if_body_;
  _impl_.if_body_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* IfThen::_internal_mutable_if_body() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.if_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::StatementSeq>(GetArenaForAllocation());
    _impl_.if_body_ = p;
  }
  return _impl_.if_body_;
}
inline ::joosc_fuzzer::StatementSeq* IfThen::mutable_if_body() {
  ::joosc_fuzzer::StatementSeq* _msg = _internal_mutable_if_body();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.IfThen.if_body)
  return _msg;
}
inline void IfThen::set_allocated_if_body(::joosc_fuzzer::StatementSeq* if_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.if_body_;
  }
  if (if_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(if_body);
    if (message_arena != submessage_arena) {
      if_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, if_body, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.if_body_ = if_body;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.IfThen.if_body)
}

// -------------------------------------------------------------------

// IfElse

// required .joosc_fuzzer.BoolRvalue cond = 1;
inline bool IfElse::_internal_has_cond() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cond_ != nullptr);
  return value;
}
inline bool IfElse::has_cond() const {
  return _internal_has_cond();
}
inline void IfElse::clear_cond() {
  if (_impl_.cond_ != nullptr) _impl_.cond_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::BoolRvalue& IfElse::_internal_cond() const {
  const ::joosc_fuzzer::BoolRvalue* p = _impl_.cond_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::BoolRvalue&>(
      ::joosc_fuzzer::_BoolRvalue_default_instance_);
}
inline const ::joosc_fuzzer::BoolRvalue& IfElse::cond() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IfElse.cond)
  return _internal_cond();
}
inline void IfElse::unsafe_arena_set_allocated_cond(
    ::joosc_fuzzer::BoolRvalue* cond) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cond_);
  }
  _impl_.cond_ = cond;
  if (cond) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.IfElse.cond)
}
inline ::joosc_fuzzer::BoolRvalue* IfElse::release_cond() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.cond_;
  _impl_.cond_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* IfElse::unsafe_arena_release_cond() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.IfElse.cond)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.cond_;
  _impl_.cond_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* IfElse::_internal_mutable_cond() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cond_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::BoolRvalue>(GetArenaForAllocation());
    _impl_.cond_ = p;
  }
  return _impl_.cond_;
}
inline ::joosc_fuzzer::BoolRvalue* IfElse::mutable_cond() {
  ::joosc_fuzzer::BoolRvalue* _msg = _internal_mutable_cond();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.IfElse.cond)
  return _msg;
}
inline void IfElse::set_allocated_cond(::joosc_fuzzer::BoolRvalue* cond) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cond_;
  }
  if (cond) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cond);
    if (message_arena != submessage_arena) {
      cond = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.IfElse.cond)
}

// required .joosc_fuzzer.StatementSeq if_body = 2;
inline bool IfElse::_internal_has_if_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.if_body_ != nullptr);
  return value;
}
inline bool IfElse::has_if_body() const {
  return _internal_has_if_body();
}
inline void IfElse::clear_if_body() {
  if (_impl_.if_body_ != nullptr) _impl_.if_body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::StatementSeq& IfElse::_internal_if_body() const {
  const ::joosc_fuzzer::StatementSeq* p = _impl_.if_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::StatementSeq&>(
      ::joosc_fuzzer::_StatementSeq_default_instance_);
}
inline const ::joosc_fuzzer::StatementSeq& IfElse::if_body() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IfElse.if_body)
  return _internal_if_body();
}
inline void IfElse::unsafe_arena_set_allocated_if_body(
    ::joosc_fuzzer::StatementSeq* if_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.if_body_);
  }
  _impl_.if_body_ = if_body;
  if (if_body) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.IfElse.if_body)
}
inline ::joosc_fuzzer::StatementSeq* IfElse::release_if_body() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.if_body_;
  _impl_.if_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* IfElse::unsafe_arena_release_if_body() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.IfElse.if_body)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.if_body_;
  _impl_.if_body_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* IfElse::_internal_mutable_if_body() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.if_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::StatementSeq>(GetArenaForAllocation());
    _impl_.if_body_ = p;
  }
  return _impl_.if_body_;
}
inline ::joosc_fuzzer::StatementSeq* IfElse::mutable_if_body() {
  ::joosc_fuzzer::StatementSeq* _msg = _internal_mutable_if_body();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.IfElse.if_body)
  return _msg;
}
inline void IfElse::set_allocated_if_body(::joosc_fuzzer::StatementSeq* if_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.if_body_;
  }
  if (if_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(if_body);
    if (message_arena != submessage_arena) {
      if_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, if_body, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.if_body_ = if_body;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.IfElse.if_body)
}

// required .joosc_fuzzer.StatementSeq else_body = 3;
inline bool IfElse::_internal_has_else_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.else_body_ != nullptr);
  return value;
}
inline bool IfElse::has_else_body() const {
  return _internal_has_else_body();
}
inline void IfElse::clear_else_body() {
  if (_impl_.else_body_ != nullptr) _impl_.else_body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::joosc_fuzzer::StatementSeq& IfElse::_internal_else_body() const {
  const ::joosc_fuzzer::StatementSeq* p = _impl_.else_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::StatementSeq&>(
      ::joosc_fuzzer::_StatementSeq_default_instance_);
}
inline const ::joosc_fuzzer::StatementSeq& IfElse::else_body() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.IfElse.else_body)
  return _internal_else_body();
}
inline void IfElse::unsafe_arena_set_allocated_else_body(
    ::joosc_fuzzer::StatementSeq* else_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.else_body_);
  }
  _impl_.else_body_ = else_body;
  if (else_body) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.IfElse.else_body)
}
inline ::joosc_fuzzer::StatementSeq* IfElse::release_else_body() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.else_body_;
  _impl_.else_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* IfElse::unsafe_arena_release_else_body() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.IfElse.else_body)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.else_body_;
  _impl_.else_body_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* IfElse::_internal_mutable_else_body() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.else_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::StatementSeq>(GetArenaForAllocation());
    _impl_.else_body_ = p;
  }
  return _impl_.else_body_;
}
inline ::joosc_fuzzer::StatementSeq* IfElse::mutable_else_body() {
  ::joosc_fuzzer::StatementSeq* _msg = _internal_mutable_else_body();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.IfElse.else_body)
  return _msg;
}
inline void IfElse::set_allocated_else_body(::joosc_fuzzer::StatementSeq* else_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.else_body_;
  }
  if (else_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(else_body);
    if (message_arena != submessage_arena) {
      else_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, else_body, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.else_body_ = else_body;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.IfElse.else_body)
}

// -------------------------------------------------------------------

// While

// required .joosc_fuzzer.BoolRvalue cond = 1;
inline bool While::_internal_has_cond() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cond_ != nullptr);
  return value;
}
inline bool While::has_cond() const {
  return _internal_has_cond();
}
inline void While::clear_cond() {
  if (_impl_.cond_ != nullptr) _impl_.cond_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::BoolRvalue& While::_internal_cond() const {
  const ::joosc_fuzzer::BoolRvalue* p = _impl_.cond_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::BoolRvalue&>(
      ::joosc_fuzzer::_BoolRvalue_default_instance_);
}
inline const ::joosc_fuzzer::BoolRvalue& While::cond() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.While.cond)
  return _internal_cond();
}
inline void While::unsafe_arena_set_allocated_cond(
    ::joosc_fuzzer::BoolRvalue* cond) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cond_);
  }
  _impl_.cond_ = cond;
  if (cond) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.While.cond)
}
inline ::joosc_fuzzer::BoolRvalue* While::release_cond() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.cond_;
  _impl_.cond_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* While::unsafe_arena_release_cond() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.While.cond)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::BoolRvalue* temp = _impl_.cond_;
  _impl_.cond_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::BoolRvalue* While::_internal_mutable_cond() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cond_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::BoolRvalue>(GetArenaForAllocation());
    _impl_.cond_ = p;
  }
  return _impl_.cond_;
}
inline ::joosc_fuzzer::BoolRvalue* While::mutable_cond() {
  ::joosc_fuzzer::BoolRvalue* _msg = _internal_mutable_cond();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.While.cond)
  return _msg;
}
inline void While::set_allocated_cond(::joosc_fuzzer::BoolRvalue* cond) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cond_;
  }
  if (cond) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cond);
    if (message_arena != submessage_arena) {
      cond = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.While.cond)
}

// required .joosc_fuzzer.StatementSeq body = 2;
inline bool While::_internal_has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline bool While::has_body() const {
  return _internal_has_body();
}
inline void While::clear_body() {
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::StatementSeq& While::_internal_body() const {
  const ::joosc_fuzzer::StatementSeq* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::StatementSeq&>(
      ::joosc_fuzzer::_StatementSeq_default_instance_);
}
inline const ::joosc_fuzzer::StatementSeq& While::body() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.While.body)
  return _internal_body();
}
inline void While::unsafe_arena_set_allocated_body(
    ::joosc_fuzzer::StatementSeq* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.While.body)
}
inline ::joosc_fuzzer::StatementSeq* While::release_body() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* While::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.While.body)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* While::_internal_mutable_body() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::StatementSeq>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::joosc_fuzzer::StatementSeq* While::mutable_body() {
  ::joosc_fuzzer::StatementSeq* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.While.body)
  return _msg;
}
inline void While::set_allocated_body(::joosc_fuzzer::StatementSeq* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.While.body)
}

// -------------------------------------------------------------------

// Statement

// .joosc_fuzzer.AssignmentStatement assignment = 1;
inline bool Statement::_internal_has_assignment() const {
  return stmt_oneof_case() == kAssignment;
}
inline bool Statement::has_assignment() const {
  return _internal_has_assignment();
}
inline void Statement::set_has_assignment() {
  _impl_._oneof_case_[0] = kAssignment;
}
inline void Statement::clear_assignment() {
  if (_internal_has_assignment()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stmt_oneof_.assignment_;
    }
    clear_has_stmt_oneof();
  }
}
inline ::joosc_fuzzer::AssignmentStatement* Statement::release_assignment() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Statement.assignment)
  if (_internal_has_assignment()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::AssignmentStatement* temp = _impl_.stmt_oneof_.assignment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stmt_oneof_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::AssignmentStatement& Statement::_internal_assignment() const {
  return _internal_has_assignment()
      ? *_impl_.stmt_oneof_.assignment_
      : reinterpret_cast< ::joosc_fuzzer::AssignmentStatement&>(::joosc_fuzzer::_AssignmentStatement_default_instance_);
}
inline const ::joosc_fuzzer::AssignmentStatement& Statement::assignment() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Statement.assignment)
  return _internal_assignment();
}
inline ::joosc_fuzzer::AssignmentStatement* Statement::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.Statement.assignment)
  if (_internal_has_assignment()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::AssignmentStatement* temp = _impl_.stmt_oneof_.assignment_;
    _impl_.stmt_oneof_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_assignment(::joosc_fuzzer::AssignmentStatement* assignment) {
  clear_stmt_oneof();
  if (assignment) {
    set_has_assignment();
    _impl_.stmt_oneof_.assignment_ = assignment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Statement.assignment)
}
inline ::joosc_fuzzer::AssignmentStatement* Statement::_internal_mutable_assignment() {
  if (!_internal_has_assignment()) {
    clear_stmt_oneof();
    set_has_assignment();
    _impl_.stmt_oneof_.assignment_ = CreateMaybeMessage< ::joosc_fuzzer::AssignmentStatement >(GetArenaForAllocation());
  }
  return _impl_.stmt_oneof_.assignment_;
}
inline ::joosc_fuzzer::AssignmentStatement* Statement::mutable_assignment() {
  ::joosc_fuzzer::AssignmentStatement* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Statement.assignment)
  return _msg;
}

// .joosc_fuzzer.IfThen ifthen = 2;
inline bool Statement::_internal_has_ifthen() const {
  return stmt_oneof_case() == kIfthen;
}
inline bool Statement::has_ifthen() const {
  return _internal_has_ifthen();
}
inline void Statement::set_has_ifthen() {
  _impl_._oneof_case_[0] = kIfthen;
}
inline void Statement::clear_ifthen() {
  if (_internal_has_ifthen()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stmt_oneof_.ifthen_;
    }
    clear_has_stmt_oneof();
  }
}
inline ::joosc_fuzzer::IfThen* Statement::release_ifthen() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Statement.ifthen)
  if (_internal_has_ifthen()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::IfThen* temp = _impl_.stmt_oneof_.ifthen_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stmt_oneof_.ifthen_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::IfThen& Statement::_internal_ifthen() const {
  return _internal_has_ifthen()
      ? *_impl_.stmt_oneof_.ifthen_
      : reinterpret_cast< ::joosc_fuzzer::IfThen&>(::joosc_fuzzer::_IfThen_default_instance_);
}
inline const ::joosc_fuzzer::IfThen& Statement::ifthen() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Statement.ifthen)
  return _internal_ifthen();
}
inline ::joosc_fuzzer::IfThen* Statement::unsafe_arena_release_ifthen() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.Statement.ifthen)
  if (_internal_has_ifthen()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::IfThen* temp = _impl_.stmt_oneof_.ifthen_;
    _impl_.stmt_oneof_.ifthen_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_ifthen(::joosc_fuzzer::IfThen* ifthen) {
  clear_stmt_oneof();
  if (ifthen) {
    set_has_ifthen();
    _impl_.stmt_oneof_.ifthen_ = ifthen;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Statement.ifthen)
}
inline ::joosc_fuzzer::IfThen* Statement::_internal_mutable_ifthen() {
  if (!_internal_has_ifthen()) {
    clear_stmt_oneof();
    set_has_ifthen();
    _impl_.stmt_oneof_.ifthen_ = CreateMaybeMessage< ::joosc_fuzzer::IfThen >(GetArenaForAllocation());
  }
  return _impl_.stmt_oneof_.ifthen_;
}
inline ::joosc_fuzzer::IfThen* Statement::mutable_ifthen() {
  ::joosc_fuzzer::IfThen* _msg = _internal_mutable_ifthen();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Statement.ifthen)
  return _msg;
}

// .joosc_fuzzer.IfElse ifelse = 3;
inline bool Statement::_internal_has_ifelse() const {
  return stmt_oneof_case() == kIfelse;
}
inline bool Statement::has_ifelse() const {
  return _internal_has_ifelse();
}
inline void Statement::set_has_ifelse() {
  _impl_._oneof_case_[0] = kIfelse;
}
inline void Statement::clear_ifelse() {
  if (_internal_has_ifelse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stmt_oneof_.ifelse_;
    }
    clear_has_stmt_oneof();
  }
}
inline ::joosc_fuzzer::IfElse* Statement::release_ifelse() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Statement.ifelse)
  if (_internal_has_ifelse()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::IfElse* temp = _impl_.stmt_oneof_.ifelse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stmt_oneof_.ifelse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::IfElse& Statement::_internal_ifelse() const {
  return _internal_has_ifelse()
      ? *_impl_.stmt_oneof_.ifelse_
      : reinterpret_cast< ::joosc_fuzzer::IfElse&>(::joosc_fuzzer::_IfElse_default_instance_);
}
inline const ::joosc_fuzzer::IfElse& Statement::ifelse() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Statement.ifelse)
  return _internal_ifelse();
}
inline ::joosc_fuzzer::IfElse* Statement::unsafe_arena_release_ifelse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.Statement.ifelse)
  if (_internal_has_ifelse()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::IfElse* temp = _impl_.stmt_oneof_.ifelse_;
    _impl_.stmt_oneof_.ifelse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_ifelse(::joosc_fuzzer::IfElse* ifelse) {
  clear_stmt_oneof();
  if (ifelse) {
    set_has_ifelse();
    _impl_.stmt_oneof_.ifelse_ = ifelse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Statement.ifelse)
}
inline ::joosc_fuzzer::IfElse* Statement::_internal_mutable_ifelse() {
  if (!_internal_has_ifelse()) {
    clear_stmt_oneof();
    set_has_ifelse();
    _impl_.stmt_oneof_.ifelse_ = CreateMaybeMessage< ::joosc_fuzzer::IfElse >(GetArenaForAllocation());
  }
  return _impl_.stmt_oneof_.ifelse_;
}
inline ::joosc_fuzzer::IfElse* Statement::mutable_ifelse() {
  ::joosc_fuzzer::IfElse* _msg = _internal_mutable_ifelse();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Statement.ifelse)
  return _msg;
}

// .joosc_fuzzer.While while_loop = 4;
inline bool Statement::_internal_has_while_loop() const {
  return stmt_oneof_case() == kWhileLoop;
}
inline bool Statement::has_while_loop() const {
  return _internal_has_while_loop();
}
inline void Statement::set_has_while_loop() {
  _impl_._oneof_case_[0] = kWhileLoop;
}
inline void Statement::clear_while_loop() {
  if (_internal_has_while_loop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.stmt_oneof_.while_loop_;
    }
    clear_has_stmt_oneof();
  }
}
inline ::joosc_fuzzer::While* Statement::release_while_loop() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Statement.while_loop)
  if (_internal_has_while_loop()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::While* temp = _impl_.stmt_oneof_.while_loop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.stmt_oneof_.while_loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::joosc_fuzzer::While& Statement::_internal_while_loop() const {
  return _internal_has_while_loop()
      ? *_impl_.stmt_oneof_.while_loop_
      : reinterpret_cast< ::joosc_fuzzer::While&>(::joosc_fuzzer::_While_default_instance_);
}
inline const ::joosc_fuzzer::While& Statement::while_loop() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Statement.while_loop)
  return _internal_while_loop();
}
inline ::joosc_fuzzer::While* Statement::unsafe_arena_release_while_loop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:joosc_fuzzer.Statement.while_loop)
  if (_internal_has_while_loop()) {
    clear_has_stmt_oneof();
    ::joosc_fuzzer::While* temp = _impl_.stmt_oneof_.while_loop_;
    _impl_.stmt_oneof_.while_loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_while_loop(::joosc_fuzzer::While* while_loop) {
  clear_stmt_oneof();
  if (while_loop) {
    set_has_while_loop();
    _impl_.stmt_oneof_.while_loop_ = while_loop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Statement.while_loop)
}
inline ::joosc_fuzzer::While* Statement::_internal_mutable_while_loop() {
  if (!_internal_has_while_loop()) {
    clear_stmt_oneof();
    set_has_while_loop();
    _impl_.stmt_oneof_.while_loop_ = CreateMaybeMessage< ::joosc_fuzzer::While >(GetArenaForAllocation());
  }
  return _impl_.stmt_oneof_.while_loop_;
}
inline ::joosc_fuzzer::While* Statement::mutable_while_loop() {
  ::joosc_fuzzer::While* _msg = _internal_mutable_while_loop();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Statement.while_loop)
  return _msg;
}

// required .joosc_fuzzer.MethodInvocationStatement method_call = 5;
inline bool Statement::_internal_has_method_call() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.method_call_ != nullptr);
  return value;
}
inline bool Statement::has_method_call() const {
  return _internal_has_method_call();
}
inline void Statement::clear_method_call() {
  if (_impl_.method_call_ != nullptr) _impl_.method_call_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::MethodInvocationStatement& Statement::_internal_method_call() const {
  const ::joosc_fuzzer::MethodInvocationStatement* p = _impl_.method_call_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::MethodInvocationStatement&>(
      ::joosc_fuzzer::_MethodInvocationStatement_default_instance_);
}
inline const ::joosc_fuzzer::MethodInvocationStatement& Statement::method_call() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Statement.method_call)
  return _internal_method_call();
}
inline void Statement::unsafe_arena_set_allocated_method_call(
    ::joosc_fuzzer::MethodInvocationStatement* method_call) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.method_call_);
  }
  _impl_.method_call_ = method_call;
  if (method_call) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Statement.method_call)
}
inline ::joosc_fuzzer::MethodInvocationStatement* Statement::release_method_call() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::MethodInvocationStatement* temp = _impl_.method_call_;
  _impl_.method_call_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::MethodInvocationStatement* Statement::unsafe_arena_release_method_call() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Statement.method_call)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::MethodInvocationStatement* temp = _impl_.method_call_;
  _impl_.method_call_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::MethodInvocationStatement* Statement::_internal_mutable_method_call() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.method_call_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::MethodInvocationStatement>(GetArenaForAllocation());
    _impl_.method_call_ = p;
  }
  return _impl_.method_call_;
}
inline ::joosc_fuzzer::MethodInvocationStatement* Statement::mutable_method_call() {
  ::joosc_fuzzer::MethodInvocationStatement* _msg = _internal_mutable_method_call();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Statement.method_call)
  return _msg;
}
inline void Statement::set_allocated_method_call(::joosc_fuzzer::MethodInvocationStatement* method_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.method_call_;
  }
  if (method_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(method_call);
    if (message_arena != submessage_arena) {
      method_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, method_call, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.method_call_ = method_call;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Statement.method_call)
}

inline bool Statement::has_stmt_oneof() const {
  return stmt_oneof_case() != STMT_ONEOF_NOT_SET;
}
inline void Statement::clear_has_stmt_oneof() {
  _impl_._oneof_case_[0] = STMT_ONEOF_NOT_SET;
}
inline Statement::StmtOneofCase Statement::stmt_oneof_case() const {
  return Statement::StmtOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StatementSeq

// repeated .joosc_fuzzer.Statement statements = 1;
inline int StatementSeq::_internal_statements_size() const {
  return _impl_.statements_.size();
}
inline int StatementSeq::statements_size() const {
  return _internal_statements_size();
}
inline void StatementSeq::clear_statements() {
  _impl_.statements_.Clear();
}
inline ::joosc_fuzzer::Statement* StatementSeq::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.StatementSeq.statements)
  return _impl_.statements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::Statement >*
StatementSeq::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:joosc_fuzzer.StatementSeq.statements)
  return &_impl_.statements_;
}
inline const ::joosc_fuzzer::Statement& StatementSeq::_internal_statements(int index) const {
  return _impl_.statements_.Get(index);
}
inline const ::joosc_fuzzer::Statement& StatementSeq::statements(int index) const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.StatementSeq.statements)
  return _internal_statements(index);
}
inline ::joosc_fuzzer::Statement* StatementSeq::_internal_add_statements() {
  return _impl_.statements_.Add();
}
inline ::joosc_fuzzer::Statement* StatementSeq::add_statements() {
  ::joosc_fuzzer::Statement* _add = _internal_add_statements();
  // @@protoc_insertion_point(field_add:joosc_fuzzer.StatementSeq.statements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::Statement >&
StatementSeq::statements() const {
  // @@protoc_insertion_point(field_list:joosc_fuzzer.StatementSeq.statements)
  return _impl_.statements_;
}

// -------------------------------------------------------------------

// StaticField

// required .joosc_fuzzer.Lvalue lvalue = 1;
inline bool StaticField::_internal_has_lvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lvalue_ != nullptr);
  return value;
}
inline bool StaticField::has_lvalue() const {
  return _internal_has_lvalue();
}
inline void StaticField::clear_lvalue() {
  if (_impl_.lvalue_ != nullptr) _impl_.lvalue_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::Lvalue& StaticField::_internal_lvalue() const {
  const ::joosc_fuzzer::Lvalue* p = _impl_.lvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Lvalue&>(
      ::joosc_fuzzer::_Lvalue_default_instance_);
}
inline const ::joosc_fuzzer::Lvalue& StaticField::lvalue() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.StaticField.lvalue)
  return _internal_lvalue();
}
inline void StaticField::unsafe_arena_set_allocated_lvalue(
    ::joosc_fuzzer::Lvalue* lvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lvalue_);
  }
  _impl_.lvalue_ = lvalue;
  if (lvalue) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.StaticField.lvalue)
}
inline ::joosc_fuzzer::Lvalue* StaticField::release_lvalue() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Lvalue* temp = _impl_.lvalue_;
  _impl_.lvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Lvalue* StaticField::unsafe_arena_release_lvalue() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.StaticField.lvalue)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::Lvalue* temp = _impl_.lvalue_;
  _impl_.lvalue_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Lvalue* StaticField::_internal_mutable_lvalue() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Lvalue>(GetArenaForAllocation());
    _impl_.lvalue_ = p;
  }
  return _impl_.lvalue_;
}
inline ::joosc_fuzzer::Lvalue* StaticField::mutable_lvalue() {
  ::joosc_fuzzer::Lvalue* _msg = _internal_mutable_lvalue();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.StaticField.lvalue)
  return _msg;
}
inline void StaticField::set_allocated_lvalue(::joosc_fuzzer::Lvalue* lvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lvalue_;
  }
  if (lvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lvalue);
    if (message_arena != submessage_arena) {
      lvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lvalue, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lvalue_ = lvalue;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.StaticField.lvalue)
}

// required .joosc_fuzzer.Const cons = 2;
inline bool StaticField::_internal_has_cons() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cons_ != nullptr);
  return value;
}
inline bool StaticField::has_cons() const {
  return _internal_has_cons();
}
inline void StaticField::clear_cons() {
  if (_impl_.cons_ != nullptr) _impl_.cons_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::joosc_fuzzer::Const& StaticField::_internal_cons() const {
  const ::joosc_fuzzer::Const* p = _impl_.cons_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::Const&>(
      ::joosc_fuzzer::_Const_default_instance_);
}
inline const ::joosc_fuzzer::Const& StaticField::cons() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.StaticField.cons)
  return _internal_cons();
}
inline void StaticField::unsafe_arena_set_allocated_cons(
    ::joosc_fuzzer::Const* cons) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cons_);
  }
  _impl_.cons_ = cons;
  if (cons) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.StaticField.cons)
}
inline ::joosc_fuzzer::Const* StaticField::release_cons() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Const* temp = _impl_.cons_;
  _impl_.cons_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::Const* StaticField::unsafe_arena_release_cons() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.StaticField.cons)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::joosc_fuzzer::Const* temp = _impl_.cons_;
  _impl_.cons_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::Const* StaticField::_internal_mutable_cons() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cons_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::Const>(GetArenaForAllocation());
    _impl_.cons_ = p;
  }
  return _impl_.cons_;
}
inline ::joosc_fuzzer::Const* StaticField::mutable_cons() {
  ::joosc_fuzzer::Const* _msg = _internal_mutable_cons();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.StaticField.cons)
  return _msg;
}
inline void StaticField::set_allocated_cons(::joosc_fuzzer::Const* cons) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cons_;
  }
  if (cons) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cons);
    if (message_arena != submessage_arena) {
      cons = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cons, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cons_ = cons;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.StaticField.cons)
}

// -------------------------------------------------------------------

// Class

// required .joosc_fuzzer.StatementSeq main_body = 1;
inline bool Class::_internal_has_main_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.main_body_ != nullptr);
  return value;
}
inline bool Class::has_main_body() const {
  return _internal_has_main_body();
}
inline void Class::clear_main_body() {
  if (_impl_.main_body_ != nullptr) _impl_.main_body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::joosc_fuzzer::StatementSeq& Class::_internal_main_body() const {
  const ::joosc_fuzzer::StatementSeq* p = _impl_.main_body_;
  return p != nullptr ? *p : reinterpret_cast<const ::joosc_fuzzer::StatementSeq&>(
      ::joosc_fuzzer::_StatementSeq_default_instance_);
}
inline const ::joosc_fuzzer::StatementSeq& Class::main_body() const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Class.main_body)
  return _internal_main_body();
}
inline void Class::unsafe_arena_set_allocated_main_body(
    ::joosc_fuzzer::StatementSeq* main_body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.main_body_);
  }
  _impl_.main_body_ = main_body;
  if (main_body) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:joosc_fuzzer.Class.main_body)
}
inline ::joosc_fuzzer::StatementSeq* Class::release_main_body() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.main_body_;
  _impl_.main_body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* Class::unsafe_arena_release_main_body() {
  // @@protoc_insertion_point(field_release:joosc_fuzzer.Class.main_body)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::joosc_fuzzer::StatementSeq* temp = _impl_.main_body_;
  _impl_.main_body_ = nullptr;
  return temp;
}
inline ::joosc_fuzzer::StatementSeq* Class::_internal_mutable_main_body() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.main_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::joosc_fuzzer::StatementSeq>(GetArenaForAllocation());
    _impl_.main_body_ = p;
  }
  return _impl_.main_body_;
}
inline ::joosc_fuzzer::StatementSeq* Class::mutable_main_body() {
  ::joosc_fuzzer::StatementSeq* _msg = _internal_mutable_main_body();
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Class.main_body)
  return _msg;
}
inline void Class::set_allocated_main_body(::joosc_fuzzer::StatementSeq* main_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.main_body_;
  }
  if (main_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(main_body);
    if (message_arena != submessage_arena) {
      main_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, main_body, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.main_body_ = main_body;
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Class.main_body)
}

// repeated .joosc_fuzzer.StaticField fields = 2;
inline int Class::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int Class::fields_size() const {
  return _internal_fields_size();
}
inline void Class::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::joosc_fuzzer::StaticField* Class::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Class.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StaticField >*
Class::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:joosc_fuzzer.Class.fields)
  return &_impl_.fields_;
}
inline const ::joosc_fuzzer::StaticField& Class::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::joosc_fuzzer::StaticField& Class::fields(int index) const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Class.fields)
  return _internal_fields(index);
}
inline ::joosc_fuzzer::StaticField* Class::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::joosc_fuzzer::StaticField* Class::add_fields() {
  ::joosc_fuzzer::StaticField* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:joosc_fuzzer.Class.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StaticField >&
Class::fields() const {
  // @@protoc_insertion_point(field_list:joosc_fuzzer.Class.fields)
  return _impl_.fields_;
}

// repeated .joosc_fuzzer.StatementSeq methods = 3;
inline int Class::_internal_methods_size() const {
  return _impl_.methods_.size();
}
inline int Class::methods_size() const {
  return _internal_methods_size();
}
inline void Class::clear_methods() {
  _impl_.methods_.Clear();
}
inline ::joosc_fuzzer::StatementSeq* Class::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:joosc_fuzzer.Class.methods)
  return _impl_.methods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StatementSeq >*
Class::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:joosc_fuzzer.Class.methods)
  return &_impl_.methods_;
}
inline const ::joosc_fuzzer::StatementSeq& Class::_internal_methods(int index) const {
  return _impl_.methods_.Get(index);
}
inline const ::joosc_fuzzer::StatementSeq& Class::methods(int index) const {
  // @@protoc_insertion_point(field_get:joosc_fuzzer.Class.methods)
  return _internal_methods(index);
}
inline ::joosc_fuzzer::StatementSeq* Class::_internal_add_methods() {
  return _impl_.methods_.Add();
}
inline ::joosc_fuzzer::StatementSeq* Class::add_methods() {
  ::joosc_fuzzer::StatementSeq* _add = _internal_add_methods();
  // @@protoc_insertion_point(field_add:joosc_fuzzer.Class.methods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::joosc_fuzzer::StatementSeq >&
Class::methods() const {
  // @@protoc_insertion_point(field_list:joosc_fuzzer.Class.methods)
  return _impl_.methods_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace joosc_fuzzer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::joosc_fuzzer::BinaryOp_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::joosc_fuzzer::BinaryOp_Op>() {
  return ::joosc_fuzzer::BinaryOp_Op_descriptor();
}
template <> struct is_proto_enum< ::joosc_fuzzer::BoolToBoolOp_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::joosc_fuzzer::BoolToBoolOp_Op>() {
  return ::joosc_fuzzer::BoolToBoolOp_Op_descriptor();
}
template <> struct is_proto_enum< ::joosc_fuzzer::IntToBoolOp_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::joosc_fuzzer::IntToBoolOp_Op>() {
  return ::joosc_fuzzer::IntToBoolOp_Op_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_joosc_5fproto_2eproto
