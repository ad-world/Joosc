// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: joosc_proto.proto

#include "joosc_proto.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace joosc_fuzzer {
PROTOBUF_CONSTEXPR VarRef::VarRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.varnum_)*/0} {}
struct VarRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VarRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VarRefDefaultTypeInternal() {}
  union {
    VarRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VarRefDefaultTypeInternal _VarRef_default_instance_;
PROTOBUF_CONSTEXPR FunctionRef::FunctionRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.funcnum_)*/0} {}
struct FunctionRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FunctionRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FunctionRefDefaultTypeInternal() {}
  union {
    FunctionRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FunctionRefDefaultTypeInternal _FunctionRef_default_instance_;
PROTOBUF_CONSTEXPR Lvalue::Lvalue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.varref_)*/nullptr} {}
struct LvalueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LvalueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LvalueDefaultTypeInternal() {}
  union {
    Lvalue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LvalueDefaultTypeInternal _Lvalue_default_instance_;
PROTOBUF_CONSTEXPR Rvalue::Rvalue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rvalue_oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RvalueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RvalueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RvalueDefaultTypeInternal() {}
  union {
    Rvalue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RvalueDefaultTypeInternal _Rvalue_default_instance_;
PROTOBUF_CONSTEXPR Const::Const(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.val_)*/0} {}
struct ConstDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstDefaultTypeInternal() {}
  union {
    Const _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstDefaultTypeInternal _Const_default_instance_;
PROTOBUF_CONSTEXPR BinaryOp::BinaryOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.left_)*/nullptr
  , /*decltype(_impl_.right_)*/nullptr
  , /*decltype(_impl_.op_)*/0} {}
struct BinaryOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BinaryOpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BinaryOpDefaultTypeInternal() {}
  union {
    BinaryOp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BinaryOpDefaultTypeInternal _BinaryOp_default_instance_;
PROTOBUF_CONSTEXPR BoolRvalue::BoolRvalue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bool_binop_oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BoolRvalueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolRvalueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolRvalueDefaultTypeInternal() {}
  union {
    BoolRvalue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolRvalueDefaultTypeInternal _BoolRvalue_default_instance_;
PROTOBUF_CONSTEXPR BoolToBoolOp::BoolToBoolOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.left_)*/nullptr
  , /*decltype(_impl_.right_)*/nullptr
  , /*decltype(_impl_.op_)*/0} {}
struct BoolToBoolOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolToBoolOpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolToBoolOpDefaultTypeInternal() {}
  union {
    BoolToBoolOp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolToBoolOpDefaultTypeInternal _BoolToBoolOp_default_instance_;
PROTOBUF_CONSTEXPR IntToBoolOp::IntToBoolOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.left_)*/nullptr
  , /*decltype(_impl_.right_)*/nullptr
  , /*decltype(_impl_.op_)*/0} {}
struct IntToBoolOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntToBoolOpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntToBoolOpDefaultTypeInternal() {}
  union {
    IntToBoolOp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntToBoolOpDefaultTypeInternal _IntToBoolOp_default_instance_;
PROTOBUF_CONSTEXPR AssignmentStatement::AssignmentStatement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lvalue_)*/nullptr
  , /*decltype(_impl_.rvalue_)*/nullptr} {}
struct AssignmentStatementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssignmentStatementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssignmentStatementDefaultTypeInternal() {}
  union {
    AssignmentStatement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssignmentStatementDefaultTypeInternal _AssignmentStatement_default_instance_;
PROTOBUF_CONSTEXPR MethodInvocation::MethodInvocation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.funcref_)*/nullptr} {}
struct MethodInvocationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MethodInvocationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MethodInvocationDefaultTypeInternal() {}
  union {
    MethodInvocation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MethodInvocationDefaultTypeInternal _MethodInvocation_default_instance_;
PROTOBUF_CONSTEXPR MethodInvocationStatement::MethodInvocationStatement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.method_invocation_)*/nullptr} {}
struct MethodInvocationStatementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MethodInvocationStatementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MethodInvocationStatementDefaultTypeInternal() {}
  union {
    MethodInvocationStatement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MethodInvocationStatementDefaultTypeInternal _MethodInvocationStatement_default_instance_;
PROTOBUF_CONSTEXPR IfThen::IfThen(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cond_)*/nullptr
  , /*decltype(_impl_.if_body_)*/nullptr} {}
struct IfThenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IfThenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IfThenDefaultTypeInternal() {}
  union {
    IfThen _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IfThenDefaultTypeInternal _IfThen_default_instance_;
PROTOBUF_CONSTEXPR IfElse::IfElse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cond_)*/nullptr
  , /*decltype(_impl_.if_body_)*/nullptr
  , /*decltype(_impl_.else_body_)*/nullptr} {}
struct IfElseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IfElseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IfElseDefaultTypeInternal() {}
  union {
    IfElse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IfElseDefaultTypeInternal _IfElse_default_instance_;
PROTOBUF_CONSTEXPR While::While(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cond_)*/nullptr
  , /*decltype(_impl_.body_)*/nullptr} {}
struct WhileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhileDefaultTypeInternal() {}
  union {
    While _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhileDefaultTypeInternal _While_default_instance_;
PROTOBUF_CONSTEXPR Statement::Statement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stmt_oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StatementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatementDefaultTypeInternal() {}
  union {
    Statement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatementDefaultTypeInternal _Statement_default_instance_;
PROTOBUF_CONSTEXPR StatementSeq::StatementSeq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.statements_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatementSeqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatementSeqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatementSeqDefaultTypeInternal() {}
  union {
    StatementSeq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatementSeqDefaultTypeInternal _StatementSeq_default_instance_;
PROTOBUF_CONSTEXPR StaticField::StaticField(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lvalue_)*/nullptr
  , /*decltype(_impl_.cons_)*/nullptr} {}
struct StaticFieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaticFieldDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaticFieldDefaultTypeInternal() {}
  union {
    StaticField _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaticFieldDefaultTypeInternal _StaticField_default_instance_;
PROTOBUF_CONSTEXPR Class::Class(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fields_)*/{}
  , /*decltype(_impl_.methods_)*/{}
  , /*decltype(_impl_.main_body_)*/nullptr} {}
struct ClassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClassDefaultTypeInternal() {}
  union {
    Class _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClassDefaultTypeInternal _Class_default_instance_;
}  // namespace joosc_fuzzer
static ::_pb::Metadata file_level_metadata_joosc_5fproto_2eproto[19];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_joosc_5fproto_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_joosc_5fproto_2eproto = nullptr;

const uint32_t TableStruct_joosc_5fproto_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::VarRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::VarRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::VarRef, _impl_.varnum_),
  0,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::FunctionRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::FunctionRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::FunctionRef, _impl_.funcnum_),
  0,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Lvalue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Lvalue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Lvalue, _impl_.varref_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Rvalue, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Rvalue, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Rvalue, _impl_.rvalue_oneof_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Const, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Const, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Const, _impl_.val_),
  0,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BinaryOp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BinaryOp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BinaryOp, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BinaryOp, _impl_.left_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BinaryOp, _impl_.right_),
  2,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolRvalue, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolRvalue, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolRvalue, _impl_.bool_binop_oneof_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolToBoolOp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolToBoolOp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolToBoolOp, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolToBoolOp, _impl_.left_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::BoolToBoolOp, _impl_.right_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IntToBoolOp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IntToBoolOp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IntToBoolOp, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IntToBoolOp, _impl_.left_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IntToBoolOp, _impl_.right_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::AssignmentStatement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::AssignmentStatement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::AssignmentStatement, _impl_.lvalue_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::AssignmentStatement, _impl_.rvalue_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::MethodInvocation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::MethodInvocation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::MethodInvocation, _impl_.funcref_),
  0,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::MethodInvocationStatement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::MethodInvocationStatement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::MethodInvocationStatement, _impl_.method_invocation_),
  0,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfThen, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfThen, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfThen, _impl_.cond_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfThen, _impl_.if_body_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfElse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfElse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfElse, _impl_.cond_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfElse, _impl_.if_body_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::IfElse, _impl_.else_body_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::While, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::While, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::While, _impl_.cond_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::While, _impl_.body_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Statement, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Statement, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Statement, _impl_.stmt_oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::StatementSeq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::StatementSeq, _impl_.statements_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::StaticField, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::StaticField, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::StaticField, _impl_.lvalue_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::StaticField, _impl_.cons_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Class, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Class, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Class, _impl_.main_body_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Class, _impl_.fields_),
  PROTOBUF_FIELD_OFFSET(::joosc_fuzzer::Class, _impl_.methods_),
  0,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::joosc_fuzzer::VarRef)},
  { 8, 15, -1, sizeof(::joosc_fuzzer::FunctionRef)},
  { 16, 23, -1, sizeof(::joosc_fuzzer::Lvalue)},
  { 24, -1, -1, sizeof(::joosc_fuzzer::Rvalue)},
  { 34, 41, -1, sizeof(::joosc_fuzzer::Const)},
  { 42, 51, -1, sizeof(::joosc_fuzzer::BinaryOp)},
  { 54, -1, -1, sizeof(::joosc_fuzzer::BoolRvalue)},
  { 64, 73, -1, sizeof(::joosc_fuzzer::BoolToBoolOp)},
  { 76, 85, -1, sizeof(::joosc_fuzzer::IntToBoolOp)},
  { 88, 96, -1, sizeof(::joosc_fuzzer::AssignmentStatement)},
  { 98, 105, -1, sizeof(::joosc_fuzzer::MethodInvocation)},
  { 106, 113, -1, sizeof(::joosc_fuzzer::MethodInvocationStatement)},
  { 114, 122, -1, sizeof(::joosc_fuzzer::IfThen)},
  { 124, 133, -1, sizeof(::joosc_fuzzer::IfElse)},
  { 136, 144, -1, sizeof(::joosc_fuzzer::While)},
  { 146, -1, -1, sizeof(::joosc_fuzzer::Statement)},
  { 158, -1, -1, sizeof(::joosc_fuzzer::StatementSeq)},
  { 165, 173, -1, sizeof(::joosc_fuzzer::StaticField)},
  { 175, 184, -1, sizeof(::joosc_fuzzer::Class)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::joosc_fuzzer::_VarRef_default_instance_._instance,
  &::joosc_fuzzer::_FunctionRef_default_instance_._instance,
  &::joosc_fuzzer::_Lvalue_default_instance_._instance,
  &::joosc_fuzzer::_Rvalue_default_instance_._instance,
  &::joosc_fuzzer::_Const_default_instance_._instance,
  &::joosc_fuzzer::_BinaryOp_default_instance_._instance,
  &::joosc_fuzzer::_BoolRvalue_default_instance_._instance,
  &::joosc_fuzzer::_BoolToBoolOp_default_instance_._instance,
  &::joosc_fuzzer::_IntToBoolOp_default_instance_._instance,
  &::joosc_fuzzer::_AssignmentStatement_default_instance_._instance,
  &::joosc_fuzzer::_MethodInvocation_default_instance_._instance,
  &::joosc_fuzzer::_MethodInvocationStatement_default_instance_._instance,
  &::joosc_fuzzer::_IfThen_default_instance_._instance,
  &::joosc_fuzzer::_IfElse_default_instance_._instance,
  &::joosc_fuzzer::_While_default_instance_._instance,
  &::joosc_fuzzer::_Statement_default_instance_._instance,
  &::joosc_fuzzer::_StatementSeq_default_instance_._instance,
  &::joosc_fuzzer::_StaticField_default_instance_._instance,
  &::joosc_fuzzer::_Class_default_instance_._instance,
};

const char descriptor_table_protodef_joosc_5fproto_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021joosc_proto.proto\022\014joosc_fuzzer\"\030\n\006Var"
  "Ref\022\016\n\006varnum\030\001 \002(\005\"\036\n\013FunctionRef\022\017\n\007fu"
  "ncnum\030\001 \002(\005\".\n\006Lvalue\022$\n\006varref\030\001 \002(\0132\024."
  "joosc_fuzzer.VarRef\"\216\001\n\006Rvalue\022&\n\006varref"
  "\030\001 \001(\0132\024.joosc_fuzzer.VarRefH\000\022#\n\004cons\030\002"
  " \001(\0132\023.joosc_fuzzer.ConstH\000\022\'\n\005binop\030\003 \001"
  "(\0132\026.joosc_fuzzer.BinaryOpH\000B\016\n\014rvalue_o"
  "neof\"\024\n\005Const\022\013\n\003val\030\001 \002(\005\"\255\001\n\010BinaryOp\022"
  "%\n\002op\030\001 \002(\0162\031.joosc_fuzzer.BinaryOp.Op\022\""
  "\n\004left\030\002 \002(\0132\024.joosc_fuzzer.Rvalue\022#\n\005ri"
  "ght\030\003 \002(\0132\024.joosc_fuzzer.Rvalue\"1\n\002Op\022\007\n"
  "\003ADD\020\000\022\007\n\003SUB\020\001\022\007\n\003MUL\020\002\022\007\n\003DIV\020\003\022\007\n\003MOD"
  "\020\004\"\212\001\n\nBoolRvalue\022,\n\006boolop\030\001 \001(\0132\032.joos"
  "c_fuzzer.BoolToBoolOpH\000\022*\n\005intop\030\002 \001(\0132\031"
  ".joosc_fuzzer.IntToBoolOpH\000\022\016\n\004cons\030\003 \001("
  "\010H\000B\022\n\020bool_binop_oneof\"\305\001\n\014BoolToBoolOp"
  "\022)\n\002op\030\001 \002(\0162\035.joosc_fuzzer.BoolToBoolOp"
  ".Op\022&\n\004left\030\002 \002(\0132\030.joosc_fuzzer.BoolRva"
  "lue\022\'\n\005right\030\003 \002(\0132\030.joosc_fuzzer.BoolRv"
  "alue\"9\n\002Op\022\007\n\003AND\020\000\022\006\n\002OR\020\001\022\010\n\004EAND\020\002\022\007\n"
  "\003EOR\020\003\022\006\n\002EQ\020\004\022\007\n\003NEQ\020\005\"\271\001\n\013IntToBoolOp\022"
  "(\n\002op\030\001 \002(\0162\034.joosc_fuzzer.IntToBoolOp.O"
  "p\022\"\n\004left\030\002 \002(\0132\024.joosc_fuzzer.Rvalue\022#\n"
  "\005right\030\003 \002(\0132\024.joosc_fuzzer.Rvalue\"7\n\002Op"
  "\022\006\n\002LT\020\000\022\006\n\002GT\020\001\022\007\n\003LEQ\020\002\022\007\n\003GEQ\020\003\022\006\n\002EQ"
  "\020\004\022\007\n\003NEQ\020\005\"a\n\023AssignmentStatement\022$\n\006lv"
  "alue\030\001 \002(\0132\024.joosc_fuzzer.Lvalue\022$\n\006rval"
  "ue\030\002 \002(\0132\024.joosc_fuzzer.Rvalue\">\n\020Method"
  "Invocation\022*\n\007funcref\030\001 \002(\0132\031.joosc_fuzz"
  "er.FunctionRef\"V\n\031MethodInvocationStatem"
  "ent\0229\n\021method_invocation\030\001 \002(\0132\036.joosc_f"
  "uzzer.MethodInvocation\"]\n\006IfThen\022&\n\004cond"
  "\030\001 \002(\0132\030.joosc_fuzzer.BoolRvalue\022+\n\007if_b"
  "ody\030\002 \002(\0132\032.joosc_fuzzer.StatementSeq\"\214\001"
  "\n\006IfElse\022&\n\004cond\030\001 \002(\0132\030.joosc_fuzzer.Bo"
  "olRvalue\022+\n\007if_body\030\002 \002(\0132\032.joosc_fuzzer"
  ".StatementSeq\022-\n\telse_body\030\003 \002(\0132\032.joosc"
  "_fuzzer.StatementSeq\"Y\n\005While\022&\n\004cond\030\001 "
  "\002(\0132\030.joosc_fuzzer.BoolRvalue\022(\n\004body\030\002 "
  "\002(\0132\032.joosc_fuzzer.StatementSeq\"\215\002\n\tStat"
  "ement\0227\n\nassignment\030\001 \001(\0132!.joosc_fuzzer"
  ".AssignmentStatementH\000\022&\n\006ifthen\030\002 \001(\0132\024"
  ".joosc_fuzzer.IfThenH\000\022&\n\006ifelse\030\003 \001(\0132\024"
  ".joosc_fuzzer.IfElseH\000\022)\n\nwhile_loop\030\004 \001"
  "(\0132\023.joosc_fuzzer.WhileH\000\022>\n\013method_call"
  "\030\005 \001(\0132\'.joosc_fuzzer.MethodInvocationSt"
  "atementH\000B\014\n\nstmt_oneof\";\n\014StatementSeq\022"
  "+\n\nstatements\030\001 \003(\0132\027.joosc_fuzzer.State"
  "ment\"V\n\013StaticField\022$\n\006lvalue\030\001 \002(\0132\024.jo"
  "osc_fuzzer.Lvalue\022!\n\004cons\030\002 \002(\0132\023.joosc_"
  "fuzzer.Const\"\216\001\n\005Class\022-\n\tmain_body\030\001 \002("
  "\0132\032.joosc_fuzzer.StatementSeq\022)\n\006fields\030"
  "\002 \003(\0132\031.joosc_fuzzer.StaticField\022+\n\007meth"
  "ods\030\003 \003(\0132\032.joosc_fuzzer.StatementSeq"
  ;
static ::_pbi::once_flag descriptor_table_joosc_5fproto_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_joosc_5fproto_2eproto = {
    false, false, 2157, descriptor_table_protodef_joosc_5fproto_2eproto,
    "joosc_proto.proto",
    &descriptor_table_joosc_5fproto_2eproto_once, nullptr, 0, 19,
    schemas, file_default_instances, TableStruct_joosc_5fproto_2eproto::offsets,
    file_level_metadata_joosc_5fproto_2eproto, file_level_enum_descriptors_joosc_5fproto_2eproto,
    file_level_service_descriptors_joosc_5fproto_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_joosc_5fproto_2eproto_getter() {
  return &descriptor_table_joosc_5fproto_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_joosc_5fproto_2eproto(&descriptor_table_joosc_5fproto_2eproto);
namespace joosc_fuzzer {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryOp_Op_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_joosc_5fproto_2eproto);
  return file_level_enum_descriptors_joosc_5fproto_2eproto[0];
}
bool BinaryOp_Op_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BinaryOp_Op BinaryOp::ADD;
constexpr BinaryOp_Op BinaryOp::SUB;
constexpr BinaryOp_Op BinaryOp::MUL;
constexpr BinaryOp_Op BinaryOp::DIV;
constexpr BinaryOp_Op BinaryOp::MOD;
constexpr BinaryOp_Op BinaryOp::Op_MIN;
constexpr BinaryOp_Op BinaryOp::Op_MAX;
constexpr int BinaryOp::Op_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BoolToBoolOp_Op_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_joosc_5fproto_2eproto);
  return file_level_enum_descriptors_joosc_5fproto_2eproto[1];
}
bool BoolToBoolOp_Op_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BoolToBoolOp_Op BoolToBoolOp::AND;
constexpr BoolToBoolOp_Op BoolToBoolOp::OR;
constexpr BoolToBoolOp_Op BoolToBoolOp::EAND;
constexpr BoolToBoolOp_Op BoolToBoolOp::EOR;
constexpr BoolToBoolOp_Op BoolToBoolOp::EQ;
constexpr BoolToBoolOp_Op BoolToBoolOp::NEQ;
constexpr BoolToBoolOp_Op BoolToBoolOp::Op_MIN;
constexpr BoolToBoolOp_Op BoolToBoolOp::Op_MAX;
constexpr int BoolToBoolOp::Op_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntToBoolOp_Op_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_joosc_5fproto_2eproto);
  return file_level_enum_descriptors_joosc_5fproto_2eproto[2];
}
bool IntToBoolOp_Op_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IntToBoolOp_Op IntToBoolOp::LT;
constexpr IntToBoolOp_Op IntToBoolOp::GT;
constexpr IntToBoolOp_Op IntToBoolOp::LEQ;
constexpr IntToBoolOp_Op IntToBoolOp::GEQ;
constexpr IntToBoolOp_Op IntToBoolOp::EQ;
constexpr IntToBoolOp_Op IntToBoolOp::NEQ;
constexpr IntToBoolOp_Op IntToBoolOp::Op_MIN;
constexpr IntToBoolOp_Op IntToBoolOp::Op_MAX;
constexpr int IntToBoolOp::Op_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class VarRef::_Internal {
 public:
  using HasBits = decltype(std::declval<VarRef>()._impl_._has_bits_);
  static void set_has_varnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VarRef::VarRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.VarRef)
}
VarRef::VarRef(const VarRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VarRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.varnum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.varnum_ = from._impl_.varnum_;
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.VarRef)
}

inline void VarRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.varnum_){0}
  };
}

VarRef::~VarRef() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.VarRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VarRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VarRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VarRef::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.VarRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.varnum_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VarRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 varnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_varnum(&has_bits);
          _impl_.varnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VarRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.VarRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 varnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_varnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.VarRef)
  return target;
}

size_t VarRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.VarRef)
  size_t total_size = 0;

  // required int32 varnum = 1;
  if (_internal_has_varnum()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_varnum());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VarRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VarRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VarRef::GetClassData() const { return &_class_data_; }


void VarRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VarRef*>(&to_msg);
  auto& from = static_cast<const VarRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.VarRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_varnum()) {
    _this->_internal_set_varnum(from._internal_varnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VarRef::CopyFrom(const VarRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.VarRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VarRef::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VarRef::InternalSwap(VarRef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.varnum_, other->_impl_.varnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VarRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[0]);
}

// ===================================================================

class FunctionRef::_Internal {
 public:
  using HasBits = decltype(std::declval<FunctionRef>()._impl_._has_bits_);
  static void set_has_funcnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FunctionRef::FunctionRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.FunctionRef)
}
FunctionRef::FunctionRef(const FunctionRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FunctionRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.funcnum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.funcnum_ = from._impl_.funcnum_;
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.FunctionRef)
}

inline void FunctionRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.funcnum_){0}
  };
}

FunctionRef::~FunctionRef() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.FunctionRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FunctionRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FunctionRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FunctionRef::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.FunctionRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.funcnum_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FunctionRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 funcnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_funcnum(&has_bits);
          _impl_.funcnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FunctionRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.FunctionRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 funcnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_funcnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.FunctionRef)
  return target;
}

size_t FunctionRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.FunctionRef)
  size_t total_size = 0;

  // required int32 funcnum = 1;
  if (_internal_has_funcnum()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_funcnum());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FunctionRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FunctionRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FunctionRef::GetClassData() const { return &_class_data_; }


void FunctionRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FunctionRef*>(&to_msg);
  auto& from = static_cast<const FunctionRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.FunctionRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_funcnum()) {
    _this->_internal_set_funcnum(from._internal_funcnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FunctionRef::CopyFrom(const FunctionRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.FunctionRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionRef::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FunctionRef::InternalSwap(FunctionRef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.funcnum_, other->_impl_.funcnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FunctionRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[1]);
}

// ===================================================================

class Lvalue::_Internal {
 public:
  using HasBits = decltype(std::declval<Lvalue>()._impl_._has_bits_);
  static const ::joosc_fuzzer::VarRef& varref(const Lvalue* msg);
  static void set_has_varref(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::joosc_fuzzer::VarRef&
Lvalue::_Internal::varref(const Lvalue* msg) {
  return *msg->_impl_.varref_;
}
Lvalue::Lvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.Lvalue)
}
Lvalue::Lvalue(const Lvalue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Lvalue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.varref_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_varref()) {
    _this->_impl_.varref_ = new ::joosc_fuzzer::VarRef(*from._impl_.varref_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.Lvalue)
}

inline void Lvalue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.varref_){nullptr}
  };
}

Lvalue::~Lvalue() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.Lvalue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lvalue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.varref_;
}

void Lvalue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lvalue::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.Lvalue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.varref_ != nullptr);
    _impl_.varref_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Lvalue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.VarRef varref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_varref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lvalue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.Lvalue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.VarRef varref = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::varref(this),
        _Internal::varref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.Lvalue)
  return target;
}

size_t Lvalue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.Lvalue)
  size_t total_size = 0;

  // required .joosc_fuzzer.VarRef varref = 1;
  if (_internal_has_varref()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.varref_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Lvalue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Lvalue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Lvalue::GetClassData() const { return &_class_data_; }


void Lvalue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Lvalue*>(&to_msg);
  auto& from = static_cast<const Lvalue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.Lvalue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_varref()) {
    _this->_internal_mutable_varref()->::joosc_fuzzer::VarRef::MergeFrom(
        from._internal_varref());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Lvalue::CopyFrom(const Lvalue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.Lvalue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lvalue::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_varref()) {
    if (!_impl_.varref_->IsInitialized()) return false;
  }
  return true;
}

void Lvalue::InternalSwap(Lvalue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.varref_, other->_impl_.varref_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Lvalue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[2]);
}

// ===================================================================

class Rvalue::_Internal {
 public:
  static const ::joosc_fuzzer::VarRef& varref(const Rvalue* msg);
  static const ::joosc_fuzzer::Const& cons(const Rvalue* msg);
  static const ::joosc_fuzzer::BinaryOp& binop(const Rvalue* msg);
};

const ::joosc_fuzzer::VarRef&
Rvalue::_Internal::varref(const Rvalue* msg) {
  return *msg->_impl_.rvalue_oneof_.varref_;
}
const ::joosc_fuzzer::Const&
Rvalue::_Internal::cons(const Rvalue* msg) {
  return *msg->_impl_.rvalue_oneof_.cons_;
}
const ::joosc_fuzzer::BinaryOp&
Rvalue::_Internal::binop(const Rvalue* msg) {
  return *msg->_impl_.rvalue_oneof_.binop_;
}
void Rvalue::set_allocated_varref(::joosc_fuzzer::VarRef* varref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rvalue_oneof();
  if (varref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varref);
    if (message_arena != submessage_arena) {
      varref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varref, submessage_arena);
    }
    set_has_varref();
    _impl_.rvalue_oneof_.varref_ = varref;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Rvalue.varref)
}
void Rvalue::set_allocated_cons(::joosc_fuzzer::Const* cons) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rvalue_oneof();
  if (cons) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cons);
    if (message_arena != submessage_arena) {
      cons = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cons, submessage_arena);
    }
    set_has_cons();
    _impl_.rvalue_oneof_.cons_ = cons;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Rvalue.cons)
}
void Rvalue::set_allocated_binop(::joosc_fuzzer::BinaryOp* binop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rvalue_oneof();
  if (binop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(binop);
    if (message_arena != submessage_arena) {
      binop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binop, submessage_arena);
    }
    set_has_binop();
    _impl_.rvalue_oneof_.binop_ = binop;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Rvalue.binop)
}
Rvalue::Rvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.Rvalue)
}
Rvalue::Rvalue(const Rvalue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Rvalue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rvalue_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_rvalue_oneof();
  switch (from.rvalue_oneof_case()) {
    case kVarref: {
      _this->_internal_mutable_varref()->::joosc_fuzzer::VarRef::MergeFrom(
          from._internal_varref());
      break;
    }
    case kCons: {
      _this->_internal_mutable_cons()->::joosc_fuzzer::Const::MergeFrom(
          from._internal_cons());
      break;
    }
    case kBinop: {
      _this->_internal_mutable_binop()->::joosc_fuzzer::BinaryOp::MergeFrom(
          from._internal_binop());
      break;
    }
    case RVALUE_ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.Rvalue)
}

inline void Rvalue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rvalue_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_rvalue_oneof();
}

Rvalue::~Rvalue() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.Rvalue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Rvalue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_rvalue_oneof()) {
    clear_rvalue_oneof();
  }
}

void Rvalue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Rvalue::clear_rvalue_oneof() {
// @@protoc_insertion_point(one_of_clear_start:joosc_fuzzer.Rvalue)
  switch (rvalue_oneof_case()) {
    case kVarref: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.rvalue_oneof_.varref_;
      }
      break;
    }
    case kCons: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.rvalue_oneof_.cons_;
      }
      break;
    }
    case kBinop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.rvalue_oneof_.binop_;
      }
      break;
    }
    case RVALUE_ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RVALUE_ONEOF_NOT_SET;
}


void Rvalue::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.Rvalue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_rvalue_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Rvalue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .joosc_fuzzer.VarRef varref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_varref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .joosc_fuzzer.Const cons = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cons(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .joosc_fuzzer.BinaryOp binop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_binop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Rvalue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.Rvalue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (rvalue_oneof_case()) {
    case kVarref: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::varref(this),
          _Internal::varref(this).GetCachedSize(), target, stream);
      break;
    }
    case kCons: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::cons(this),
          _Internal::cons(this).GetCachedSize(), target, stream);
      break;
    }
    case kBinop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::binop(this),
          _Internal::binop(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.Rvalue)
  return target;
}

size_t Rvalue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.Rvalue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (rvalue_oneof_case()) {
    // .joosc_fuzzer.VarRef varref = 1;
    case kVarref: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rvalue_oneof_.varref_);
      break;
    }
    // .joosc_fuzzer.Const cons = 2;
    case kCons: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rvalue_oneof_.cons_);
      break;
    }
    // .joosc_fuzzer.BinaryOp binop = 3;
    case kBinop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rvalue_oneof_.binop_);
      break;
    }
    case RVALUE_ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Rvalue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Rvalue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Rvalue::GetClassData() const { return &_class_data_; }


void Rvalue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Rvalue*>(&to_msg);
  auto& from = static_cast<const Rvalue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.Rvalue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.rvalue_oneof_case()) {
    case kVarref: {
      _this->_internal_mutable_varref()->::joosc_fuzzer::VarRef::MergeFrom(
          from._internal_varref());
      break;
    }
    case kCons: {
      _this->_internal_mutable_cons()->::joosc_fuzzer::Const::MergeFrom(
          from._internal_cons());
      break;
    }
    case kBinop: {
      _this->_internal_mutable_binop()->::joosc_fuzzer::BinaryOp::MergeFrom(
          from._internal_binop());
      break;
    }
    case RVALUE_ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Rvalue::CopyFrom(const Rvalue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.Rvalue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rvalue::IsInitialized() const {
  switch (rvalue_oneof_case()) {
    case kVarref: {
      if (_internal_has_varref()) {
        if (!_impl_.rvalue_oneof_.varref_->IsInitialized()) return false;
      }
      break;
    }
    case kCons: {
      if (_internal_has_cons()) {
        if (!_impl_.rvalue_oneof_.cons_->IsInitialized()) return false;
      }
      break;
    }
    case kBinop: {
      if (_internal_has_binop()) {
        if (!_impl_.rvalue_oneof_.binop_->IsInitialized()) return false;
      }
      break;
    }
    case RVALUE_ONEOF_NOT_SET: {
      break;
    }
  }
  return true;
}

void Rvalue::InternalSwap(Rvalue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.rvalue_oneof_, other->_impl_.rvalue_oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Rvalue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[3]);
}

// ===================================================================

class Const::_Internal {
 public:
  using HasBits = decltype(std::declval<Const>()._impl_._has_bits_);
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Const::Const(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.Const)
}
Const::Const(const Const& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Const* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.val_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.val_ = from._impl_.val_;
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.Const)
}

inline void Const::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.val_){0}
  };
}

Const::~Const() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.Const)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Const::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Const::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Const::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.Const)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.val_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Const::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_val(&has_bits);
          _impl_.val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Const::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.Const)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 val = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.Const)
  return target;
}

size_t Const::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.Const)
  size_t total_size = 0;

  // required int32 val = 1;
  if (_internal_has_val()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_val());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Const::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Const::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Const::GetClassData() const { return &_class_data_; }


void Const::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Const*>(&to_msg);
  auto& from = static_cast<const Const&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.Const)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_val()) {
    _this->_internal_set_val(from._internal_val());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Const::CopyFrom(const Const& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.Const)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Const::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Const::InternalSwap(Const* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.val_, other->_impl_.val_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Const::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[4]);
}

// ===================================================================

class BinaryOp::_Internal {
 public:
  using HasBits = decltype(std::declval<BinaryOp>()._impl_._has_bits_);
  static void set_has_op(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::joosc_fuzzer::Rvalue& left(const BinaryOp* msg);
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::Rvalue& right(const BinaryOp* msg);
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::joosc_fuzzer::Rvalue&
BinaryOp::_Internal::left(const BinaryOp* msg) {
  return *msg->_impl_.left_;
}
const ::joosc_fuzzer::Rvalue&
BinaryOp::_Internal::right(const BinaryOp* msg) {
  return *msg->_impl_.right_;
}
BinaryOp::BinaryOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.BinaryOp)
}
BinaryOp::BinaryOp(const BinaryOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BinaryOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
    , decltype(_impl_.op_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_left()) {
    _this->_impl_.left_ = new ::joosc_fuzzer::Rvalue(*from._impl_.left_);
  }
  if (from._internal_has_right()) {
    _this->_impl_.right_ = new ::joosc_fuzzer::Rvalue(*from._impl_.right_);
  }
  _this->_impl_.op_ = from._impl_.op_;
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.BinaryOp)
}

inline void BinaryOp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
    , decltype(_impl_.op_){0}
  };
}

BinaryOp::~BinaryOp() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.BinaryOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BinaryOp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.left_;
  if (this != internal_default_instance()) delete _impl_.right_;
}

void BinaryOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BinaryOp::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.BinaryOp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.left_ != nullptr);
      _impl_.left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.right_ != nullptr);
      _impl_.right_->Clear();
    }
  }
  _impl_.op_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BinaryOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.BinaryOp.Op op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::joosc_fuzzer::BinaryOp_Op_IsValid(val))) {
            _internal_set_op(static_cast<::joosc_fuzzer::BinaryOp_Op>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.Rvalue left = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_left(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.Rvalue right = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_right(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BinaryOp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.BinaryOp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.BinaryOp.Op op = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op(), target);
  }

  // required .joosc_fuzzer.Rvalue left = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::left(this),
        _Internal::left(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.Rvalue right = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::right(this),
        _Internal::right(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.BinaryOp)
  return target;
}

size_t BinaryOp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.BinaryOp)
  size_t total_size = 0;

  if (_internal_has_left()) {
    // required .joosc_fuzzer.Rvalue left = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.left_);
  }

  if (_internal_has_right()) {
    // required .joosc_fuzzer.Rvalue right = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.right_);
  }

  if (_internal_has_op()) {
    // required .joosc_fuzzer.BinaryOp.Op op = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());
  }

  return total_size;
}
size_t BinaryOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.BinaryOp)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.Rvalue left = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.left_);

    // required .joosc_fuzzer.Rvalue right = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.right_);

    // required .joosc_fuzzer.BinaryOp.Op op = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BinaryOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BinaryOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BinaryOp::GetClassData() const { return &_class_data_; }


void BinaryOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BinaryOp*>(&to_msg);
  auto& from = static_cast<const BinaryOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.BinaryOp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_left()->::joosc_fuzzer::Rvalue::MergeFrom(
          from._internal_left());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_right()->::joosc_fuzzer::Rvalue::MergeFrom(
          from._internal_right());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.op_ = from._impl_.op_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BinaryOp::CopyFrom(const BinaryOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.BinaryOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BinaryOp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_left()) {
    if (!_impl_.left_->IsInitialized()) return false;
  }
  if (_internal_has_right()) {
    if (!_impl_.right_->IsInitialized()) return false;
  }
  return true;
}

void BinaryOp::InternalSwap(BinaryOp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BinaryOp, _impl_.op_)
      + sizeof(BinaryOp::_impl_.op_)
      - PROTOBUF_FIELD_OFFSET(BinaryOp, _impl_.left_)>(
          reinterpret_cast<char*>(&_impl_.left_),
          reinterpret_cast<char*>(&other->_impl_.left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BinaryOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[5]);
}

// ===================================================================

class BoolRvalue::_Internal {
 public:
  static const ::joosc_fuzzer::BoolToBoolOp& boolop(const BoolRvalue* msg);
  static const ::joosc_fuzzer::IntToBoolOp& intop(const BoolRvalue* msg);
};

const ::joosc_fuzzer::BoolToBoolOp&
BoolRvalue::_Internal::boolop(const BoolRvalue* msg) {
  return *msg->_impl_.bool_binop_oneof_.boolop_;
}
const ::joosc_fuzzer::IntToBoolOp&
BoolRvalue::_Internal::intop(const BoolRvalue* msg) {
  return *msg->_impl_.bool_binop_oneof_.intop_;
}
void BoolRvalue::set_allocated_boolop(::joosc_fuzzer::BoolToBoolOp* boolop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_bool_binop_oneof();
  if (boolop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boolop);
    if (message_arena != submessage_arena) {
      boolop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boolop, submessage_arena);
    }
    set_has_boolop();
    _impl_.bool_binop_oneof_.boolop_ = boolop;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.BoolRvalue.boolop)
}
void BoolRvalue::set_allocated_intop(::joosc_fuzzer::IntToBoolOp* intop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_bool_binop_oneof();
  if (intop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intop);
    if (message_arena != submessage_arena) {
      intop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intop, submessage_arena);
    }
    set_has_intop();
    _impl_.bool_binop_oneof_.intop_ = intop;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.BoolRvalue.intop)
}
BoolRvalue::BoolRvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.BoolRvalue)
}
BoolRvalue::BoolRvalue(const BoolRvalue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoolRvalue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bool_binop_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_bool_binop_oneof();
  switch (from.bool_binop_oneof_case()) {
    case kBoolop: {
      _this->_internal_mutable_boolop()->::joosc_fuzzer::BoolToBoolOp::MergeFrom(
          from._internal_boolop());
      break;
    }
    case kIntop: {
      _this->_internal_mutable_intop()->::joosc_fuzzer::IntToBoolOp::MergeFrom(
          from._internal_intop());
      break;
    }
    case kCons: {
      _this->_internal_set_cons(from._internal_cons());
      break;
    }
    case BOOL_BINOP_ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.BoolRvalue)
}

inline void BoolRvalue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bool_binop_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_bool_binop_oneof();
}

BoolRvalue::~BoolRvalue() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.BoolRvalue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoolRvalue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_bool_binop_oneof()) {
    clear_bool_binop_oneof();
  }
}

void BoolRvalue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoolRvalue::clear_bool_binop_oneof() {
// @@protoc_insertion_point(one_of_clear_start:joosc_fuzzer.BoolRvalue)
  switch (bool_binop_oneof_case()) {
    case kBoolop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.bool_binop_oneof_.boolop_;
      }
      break;
    }
    case kIntop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.bool_binop_oneof_.intop_;
      }
      break;
    }
    case kCons: {
      // No need to clear
      break;
    }
    case BOOL_BINOP_ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BOOL_BINOP_ONEOF_NOT_SET;
}


void BoolRvalue::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.BoolRvalue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_bool_binop_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoolRvalue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .joosc_fuzzer.BoolToBoolOp boolop = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_boolop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .joosc_fuzzer.IntToBoolOp intop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_intop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool cons = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_cons(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoolRvalue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.BoolRvalue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (bool_binop_oneof_case()) {
    case kBoolop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::boolop(this),
          _Internal::boolop(this).GetCachedSize(), target, stream);
      break;
    }
    case kIntop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::intop(this),
          _Internal::intop(this).GetCachedSize(), target, stream);
      break;
    }
    case kCons: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_cons(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.BoolRvalue)
  return target;
}

size_t BoolRvalue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.BoolRvalue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (bool_binop_oneof_case()) {
    // .joosc_fuzzer.BoolToBoolOp boolop = 1;
    case kBoolop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bool_binop_oneof_.boolop_);
      break;
    }
    // .joosc_fuzzer.IntToBoolOp intop = 2;
    case kIntop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bool_binop_oneof_.intop_);
      break;
    }
    // bool cons = 3;
    case kCons: {
      total_size += 1 + 1;
      break;
    }
    case BOOL_BINOP_ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoolRvalue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoolRvalue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoolRvalue::GetClassData() const { return &_class_data_; }


void BoolRvalue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoolRvalue*>(&to_msg);
  auto& from = static_cast<const BoolRvalue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.BoolRvalue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.bool_binop_oneof_case()) {
    case kBoolop: {
      _this->_internal_mutable_boolop()->::joosc_fuzzer::BoolToBoolOp::MergeFrom(
          from._internal_boolop());
      break;
    }
    case kIntop: {
      _this->_internal_mutable_intop()->::joosc_fuzzer::IntToBoolOp::MergeFrom(
          from._internal_intop());
      break;
    }
    case kCons: {
      _this->_internal_set_cons(from._internal_cons());
      break;
    }
    case BOOL_BINOP_ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoolRvalue::CopyFrom(const BoolRvalue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.BoolRvalue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoolRvalue::IsInitialized() const {
  switch (bool_binop_oneof_case()) {
    case kBoolop: {
      if (_internal_has_boolop()) {
        if (!_impl_.bool_binop_oneof_.boolop_->IsInitialized()) return false;
      }
      break;
    }
    case kIntop: {
      if (_internal_has_intop()) {
        if (!_impl_.bool_binop_oneof_.intop_->IsInitialized()) return false;
      }
      break;
    }
    case kCons: {
      break;
    }
    case BOOL_BINOP_ONEOF_NOT_SET: {
      break;
    }
  }
  return true;
}

void BoolRvalue::InternalSwap(BoolRvalue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.bool_binop_oneof_, other->_impl_.bool_binop_oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BoolRvalue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[6]);
}

// ===================================================================

class BoolToBoolOp::_Internal {
 public:
  using HasBits = decltype(std::declval<BoolToBoolOp>()._impl_._has_bits_);
  static void set_has_op(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::joosc_fuzzer::BoolRvalue& left(const BoolToBoolOp* msg);
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::BoolRvalue& right(const BoolToBoolOp* msg);
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::joosc_fuzzer::BoolRvalue&
BoolToBoolOp::_Internal::left(const BoolToBoolOp* msg) {
  return *msg->_impl_.left_;
}
const ::joosc_fuzzer::BoolRvalue&
BoolToBoolOp::_Internal::right(const BoolToBoolOp* msg) {
  return *msg->_impl_.right_;
}
BoolToBoolOp::BoolToBoolOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.BoolToBoolOp)
}
BoolToBoolOp::BoolToBoolOp(const BoolToBoolOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoolToBoolOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
    , decltype(_impl_.op_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_left()) {
    _this->_impl_.left_ = new ::joosc_fuzzer::BoolRvalue(*from._impl_.left_);
  }
  if (from._internal_has_right()) {
    _this->_impl_.right_ = new ::joosc_fuzzer::BoolRvalue(*from._impl_.right_);
  }
  _this->_impl_.op_ = from._impl_.op_;
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.BoolToBoolOp)
}

inline void BoolToBoolOp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
    , decltype(_impl_.op_){0}
  };
}

BoolToBoolOp::~BoolToBoolOp() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.BoolToBoolOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoolToBoolOp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.left_;
  if (this != internal_default_instance()) delete _impl_.right_;
}

void BoolToBoolOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoolToBoolOp::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.BoolToBoolOp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.left_ != nullptr);
      _impl_.left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.right_ != nullptr);
      _impl_.right_->Clear();
    }
  }
  _impl_.op_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoolToBoolOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.BoolToBoolOp.Op op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::joosc_fuzzer::BoolToBoolOp_Op_IsValid(val))) {
            _internal_set_op(static_cast<::joosc_fuzzer::BoolToBoolOp_Op>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.BoolRvalue left = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_left(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.BoolRvalue right = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_right(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoolToBoolOp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.BoolToBoolOp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.BoolToBoolOp.Op op = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op(), target);
  }

  // required .joosc_fuzzer.BoolRvalue left = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::left(this),
        _Internal::left(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.BoolRvalue right = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::right(this),
        _Internal::right(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.BoolToBoolOp)
  return target;
}

size_t BoolToBoolOp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.BoolToBoolOp)
  size_t total_size = 0;

  if (_internal_has_left()) {
    // required .joosc_fuzzer.BoolRvalue left = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.left_);
  }

  if (_internal_has_right()) {
    // required .joosc_fuzzer.BoolRvalue right = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.right_);
  }

  if (_internal_has_op()) {
    // required .joosc_fuzzer.BoolToBoolOp.Op op = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());
  }

  return total_size;
}
size_t BoolToBoolOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.BoolToBoolOp)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.BoolRvalue left = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.left_);

    // required .joosc_fuzzer.BoolRvalue right = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.right_);

    // required .joosc_fuzzer.BoolToBoolOp.Op op = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoolToBoolOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoolToBoolOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoolToBoolOp::GetClassData() const { return &_class_data_; }


void BoolToBoolOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoolToBoolOp*>(&to_msg);
  auto& from = static_cast<const BoolToBoolOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.BoolToBoolOp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_left()->::joosc_fuzzer::BoolRvalue::MergeFrom(
          from._internal_left());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_right()->::joosc_fuzzer::BoolRvalue::MergeFrom(
          from._internal_right());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.op_ = from._impl_.op_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoolToBoolOp::CopyFrom(const BoolToBoolOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.BoolToBoolOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoolToBoolOp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_left()) {
    if (!_impl_.left_->IsInitialized()) return false;
  }
  if (_internal_has_right()) {
    if (!_impl_.right_->IsInitialized()) return false;
  }
  return true;
}

void BoolToBoolOp::InternalSwap(BoolToBoolOp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BoolToBoolOp, _impl_.op_)
      + sizeof(BoolToBoolOp::_impl_.op_)
      - PROTOBUF_FIELD_OFFSET(BoolToBoolOp, _impl_.left_)>(
          reinterpret_cast<char*>(&_impl_.left_),
          reinterpret_cast<char*>(&other->_impl_.left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BoolToBoolOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[7]);
}

// ===================================================================

class IntToBoolOp::_Internal {
 public:
  using HasBits = decltype(std::declval<IntToBoolOp>()._impl_._has_bits_);
  static void set_has_op(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::joosc_fuzzer::Rvalue& left(const IntToBoolOp* msg);
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::Rvalue& right(const IntToBoolOp* msg);
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::joosc_fuzzer::Rvalue&
IntToBoolOp::_Internal::left(const IntToBoolOp* msg) {
  return *msg->_impl_.left_;
}
const ::joosc_fuzzer::Rvalue&
IntToBoolOp::_Internal::right(const IntToBoolOp* msg) {
  return *msg->_impl_.right_;
}
IntToBoolOp::IntToBoolOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.IntToBoolOp)
}
IntToBoolOp::IntToBoolOp(const IntToBoolOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntToBoolOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
    , decltype(_impl_.op_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_left()) {
    _this->_impl_.left_ = new ::joosc_fuzzer::Rvalue(*from._impl_.left_);
  }
  if (from._internal_has_right()) {
    _this->_impl_.right_ = new ::joosc_fuzzer::Rvalue(*from._impl_.right_);
  }
  _this->_impl_.op_ = from._impl_.op_;
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.IntToBoolOp)
}

inline void IntToBoolOp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
    , decltype(_impl_.op_){0}
  };
}

IntToBoolOp::~IntToBoolOp() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.IntToBoolOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntToBoolOp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.left_;
  if (this != internal_default_instance()) delete _impl_.right_;
}

void IntToBoolOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntToBoolOp::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.IntToBoolOp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.left_ != nullptr);
      _impl_.left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.right_ != nullptr);
      _impl_.right_->Clear();
    }
  }
  _impl_.op_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntToBoolOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.IntToBoolOp.Op op = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::joosc_fuzzer::IntToBoolOp_Op_IsValid(val))) {
            _internal_set_op(static_cast<::joosc_fuzzer::IntToBoolOp_Op>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.Rvalue left = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_left(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.Rvalue right = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_right(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IntToBoolOp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.IntToBoolOp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.IntToBoolOp.Op op = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op(), target);
  }

  // required .joosc_fuzzer.Rvalue left = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::left(this),
        _Internal::left(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.Rvalue right = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::right(this),
        _Internal::right(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.IntToBoolOp)
  return target;
}

size_t IntToBoolOp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.IntToBoolOp)
  size_t total_size = 0;

  if (_internal_has_left()) {
    // required .joosc_fuzzer.Rvalue left = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.left_);
  }

  if (_internal_has_right()) {
    // required .joosc_fuzzer.Rvalue right = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.right_);
  }

  if (_internal_has_op()) {
    // required .joosc_fuzzer.IntToBoolOp.Op op = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());
  }

  return total_size;
}
size_t IntToBoolOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.IntToBoolOp)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.Rvalue left = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.left_);

    // required .joosc_fuzzer.Rvalue right = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.right_);

    // required .joosc_fuzzer.IntToBoolOp.Op op = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntToBoolOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntToBoolOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntToBoolOp::GetClassData() const { return &_class_data_; }


void IntToBoolOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntToBoolOp*>(&to_msg);
  auto& from = static_cast<const IntToBoolOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.IntToBoolOp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_left()->::joosc_fuzzer::Rvalue::MergeFrom(
          from._internal_left());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_right()->::joosc_fuzzer::Rvalue::MergeFrom(
          from._internal_right());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.op_ = from._impl_.op_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntToBoolOp::CopyFrom(const IntToBoolOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.IntToBoolOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntToBoolOp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_left()) {
    if (!_impl_.left_->IsInitialized()) return false;
  }
  if (_internal_has_right()) {
    if (!_impl_.right_->IsInitialized()) return false;
  }
  return true;
}

void IntToBoolOp::InternalSwap(IntToBoolOp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntToBoolOp, _impl_.op_)
      + sizeof(IntToBoolOp::_impl_.op_)
      - PROTOBUF_FIELD_OFFSET(IntToBoolOp, _impl_.left_)>(
          reinterpret_cast<char*>(&_impl_.left_),
          reinterpret_cast<char*>(&other->_impl_.left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IntToBoolOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[8]);
}

// ===================================================================

class AssignmentStatement::_Internal {
 public:
  using HasBits = decltype(std::declval<AssignmentStatement>()._impl_._has_bits_);
  static const ::joosc_fuzzer::Lvalue& lvalue(const AssignmentStatement* msg);
  static void set_has_lvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::Rvalue& rvalue(const AssignmentStatement* msg);
  static void set_has_rvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::joosc_fuzzer::Lvalue&
AssignmentStatement::_Internal::lvalue(const AssignmentStatement* msg) {
  return *msg->_impl_.lvalue_;
}
const ::joosc_fuzzer::Rvalue&
AssignmentStatement::_Internal::rvalue(const AssignmentStatement* msg) {
  return *msg->_impl_.rvalue_;
}
AssignmentStatement::AssignmentStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.AssignmentStatement)
}
AssignmentStatement::AssignmentStatement(const AssignmentStatement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AssignmentStatement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lvalue_){nullptr}
    , decltype(_impl_.rvalue_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_lvalue()) {
    _this->_impl_.lvalue_ = new ::joosc_fuzzer::Lvalue(*from._impl_.lvalue_);
  }
  if (from._internal_has_rvalue()) {
    _this->_impl_.rvalue_ = new ::joosc_fuzzer::Rvalue(*from._impl_.rvalue_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.AssignmentStatement)
}

inline void AssignmentStatement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lvalue_){nullptr}
    , decltype(_impl_.rvalue_){nullptr}
  };
}

AssignmentStatement::~AssignmentStatement() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.AssignmentStatement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AssignmentStatement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.lvalue_;
  if (this != internal_default_instance()) delete _impl_.rvalue_;
}

void AssignmentStatement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AssignmentStatement::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.AssignmentStatement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.lvalue_ != nullptr);
      _impl_.lvalue_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rvalue_ != nullptr);
      _impl_.rvalue_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AssignmentStatement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.Lvalue lvalue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_lvalue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.Rvalue rvalue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rvalue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AssignmentStatement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.AssignmentStatement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.Lvalue lvalue = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::lvalue(this),
        _Internal::lvalue(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.Rvalue rvalue = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rvalue(this),
        _Internal::rvalue(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.AssignmentStatement)
  return target;
}

size_t AssignmentStatement::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.AssignmentStatement)
  size_t total_size = 0;

  if (_internal_has_lvalue()) {
    // required .joosc_fuzzer.Lvalue lvalue = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lvalue_);
  }

  if (_internal_has_rvalue()) {
    // required .joosc_fuzzer.Rvalue rvalue = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rvalue_);
  }

  return total_size;
}
size_t AssignmentStatement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.AssignmentStatement)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.Lvalue lvalue = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lvalue_);

    // required .joosc_fuzzer.Rvalue rvalue = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rvalue_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AssignmentStatement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AssignmentStatement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AssignmentStatement::GetClassData() const { return &_class_data_; }


void AssignmentStatement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AssignmentStatement*>(&to_msg);
  auto& from = static_cast<const AssignmentStatement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.AssignmentStatement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_lvalue()->::joosc_fuzzer::Lvalue::MergeFrom(
          from._internal_lvalue());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rvalue()->::joosc_fuzzer::Rvalue::MergeFrom(
          from._internal_rvalue());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AssignmentStatement::CopyFrom(const AssignmentStatement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.AssignmentStatement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssignmentStatement::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_lvalue()) {
    if (!_impl_.lvalue_->IsInitialized()) return false;
  }
  if (_internal_has_rvalue()) {
    if (!_impl_.rvalue_->IsInitialized()) return false;
  }
  return true;
}

void AssignmentStatement::InternalSwap(AssignmentStatement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AssignmentStatement, _impl_.rvalue_)
      + sizeof(AssignmentStatement::_impl_.rvalue_)
      - PROTOBUF_FIELD_OFFSET(AssignmentStatement, _impl_.lvalue_)>(
          reinterpret_cast<char*>(&_impl_.lvalue_),
          reinterpret_cast<char*>(&other->_impl_.lvalue_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AssignmentStatement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[9]);
}

// ===================================================================

class MethodInvocation::_Internal {
 public:
  using HasBits = decltype(std::declval<MethodInvocation>()._impl_._has_bits_);
  static const ::joosc_fuzzer::FunctionRef& funcref(const MethodInvocation* msg);
  static void set_has_funcref(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::joosc_fuzzer::FunctionRef&
MethodInvocation::_Internal::funcref(const MethodInvocation* msg) {
  return *msg->_impl_.funcref_;
}
MethodInvocation::MethodInvocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.MethodInvocation)
}
MethodInvocation::MethodInvocation(const MethodInvocation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MethodInvocation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.funcref_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_funcref()) {
    _this->_impl_.funcref_ = new ::joosc_fuzzer::FunctionRef(*from._impl_.funcref_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.MethodInvocation)
}

inline void MethodInvocation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.funcref_){nullptr}
  };
}

MethodInvocation::~MethodInvocation() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.MethodInvocation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MethodInvocation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.funcref_;
}

void MethodInvocation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MethodInvocation::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.MethodInvocation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.funcref_ != nullptr);
    _impl_.funcref_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MethodInvocation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.FunctionRef funcref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_funcref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MethodInvocation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.MethodInvocation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.FunctionRef funcref = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::funcref(this),
        _Internal::funcref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.MethodInvocation)
  return target;
}

size_t MethodInvocation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.MethodInvocation)
  size_t total_size = 0;

  // required .joosc_fuzzer.FunctionRef funcref = 1;
  if (_internal_has_funcref()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.funcref_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MethodInvocation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MethodInvocation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MethodInvocation::GetClassData() const { return &_class_data_; }


void MethodInvocation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MethodInvocation*>(&to_msg);
  auto& from = static_cast<const MethodInvocation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.MethodInvocation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_funcref()) {
    _this->_internal_mutable_funcref()->::joosc_fuzzer::FunctionRef::MergeFrom(
        from._internal_funcref());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MethodInvocation::CopyFrom(const MethodInvocation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.MethodInvocation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MethodInvocation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_funcref()) {
    if (!_impl_.funcref_->IsInitialized()) return false;
  }
  return true;
}

void MethodInvocation::InternalSwap(MethodInvocation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.funcref_, other->_impl_.funcref_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MethodInvocation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[10]);
}

// ===================================================================

class MethodInvocationStatement::_Internal {
 public:
  using HasBits = decltype(std::declval<MethodInvocationStatement>()._impl_._has_bits_);
  static const ::joosc_fuzzer::MethodInvocation& method_invocation(const MethodInvocationStatement* msg);
  static void set_has_method_invocation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::joosc_fuzzer::MethodInvocation&
MethodInvocationStatement::_Internal::method_invocation(const MethodInvocationStatement* msg) {
  return *msg->_impl_.method_invocation_;
}
MethodInvocationStatement::MethodInvocationStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.MethodInvocationStatement)
}
MethodInvocationStatement::MethodInvocationStatement(const MethodInvocationStatement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MethodInvocationStatement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.method_invocation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_method_invocation()) {
    _this->_impl_.method_invocation_ = new ::joosc_fuzzer::MethodInvocation(*from._impl_.method_invocation_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.MethodInvocationStatement)
}

inline void MethodInvocationStatement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.method_invocation_){nullptr}
  };
}

MethodInvocationStatement::~MethodInvocationStatement() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.MethodInvocationStatement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MethodInvocationStatement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.method_invocation_;
}

void MethodInvocationStatement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MethodInvocationStatement::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.MethodInvocationStatement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.method_invocation_ != nullptr);
    _impl_.method_invocation_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MethodInvocationStatement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.MethodInvocation method_invocation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_method_invocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MethodInvocationStatement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.MethodInvocationStatement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.MethodInvocation method_invocation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::method_invocation(this),
        _Internal::method_invocation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.MethodInvocationStatement)
  return target;
}

size_t MethodInvocationStatement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.MethodInvocationStatement)
  size_t total_size = 0;

  // required .joosc_fuzzer.MethodInvocation method_invocation = 1;
  if (_internal_has_method_invocation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.method_invocation_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MethodInvocationStatement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MethodInvocationStatement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MethodInvocationStatement::GetClassData() const { return &_class_data_; }


void MethodInvocationStatement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MethodInvocationStatement*>(&to_msg);
  auto& from = static_cast<const MethodInvocationStatement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.MethodInvocationStatement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_method_invocation()) {
    _this->_internal_mutable_method_invocation()->::joosc_fuzzer::MethodInvocation::MergeFrom(
        from._internal_method_invocation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MethodInvocationStatement::CopyFrom(const MethodInvocationStatement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.MethodInvocationStatement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MethodInvocationStatement::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_method_invocation()) {
    if (!_impl_.method_invocation_->IsInitialized()) return false;
  }
  return true;
}

void MethodInvocationStatement::InternalSwap(MethodInvocationStatement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.method_invocation_, other->_impl_.method_invocation_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MethodInvocationStatement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[11]);
}

// ===================================================================

class IfThen::_Internal {
 public:
  using HasBits = decltype(std::declval<IfThen>()._impl_._has_bits_);
  static const ::joosc_fuzzer::BoolRvalue& cond(const IfThen* msg);
  static void set_has_cond(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::StatementSeq& if_body(const IfThen* msg);
  static void set_has_if_body(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::joosc_fuzzer::BoolRvalue&
IfThen::_Internal::cond(const IfThen* msg) {
  return *msg->_impl_.cond_;
}
const ::joosc_fuzzer::StatementSeq&
IfThen::_Internal::if_body(const IfThen* msg) {
  return *msg->_impl_.if_body_;
}
IfThen::IfThen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.IfThen)
}
IfThen::IfThen(const IfThen& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IfThen* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cond_){nullptr}
    , decltype(_impl_.if_body_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cond()) {
    _this->_impl_.cond_ = new ::joosc_fuzzer::BoolRvalue(*from._impl_.cond_);
  }
  if (from._internal_has_if_body()) {
    _this->_impl_.if_body_ = new ::joosc_fuzzer::StatementSeq(*from._impl_.if_body_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.IfThen)
}

inline void IfThen::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cond_){nullptr}
    , decltype(_impl_.if_body_){nullptr}
  };
}

IfThen::~IfThen() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.IfThen)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IfThen::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cond_;
  if (this != internal_default_instance()) delete _impl_.if_body_;
}

void IfThen::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IfThen::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.IfThen)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cond_ != nullptr);
      _impl_.cond_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.if_body_ != nullptr);
      _impl_.if_body_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IfThen::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.BoolRvalue cond = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cond(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.StatementSeq if_body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_if_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IfThen::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.IfThen)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.BoolRvalue cond = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cond(this),
        _Internal::cond(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.StatementSeq if_body = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::if_body(this),
        _Internal::if_body(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.IfThen)
  return target;
}

size_t IfThen::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.IfThen)
  size_t total_size = 0;

  if (_internal_has_cond()) {
    // required .joosc_fuzzer.BoolRvalue cond = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cond_);
  }

  if (_internal_has_if_body()) {
    // required .joosc_fuzzer.StatementSeq if_body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.if_body_);
  }

  return total_size;
}
size_t IfThen::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.IfThen)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.BoolRvalue cond = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cond_);

    // required .joosc_fuzzer.StatementSeq if_body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.if_body_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IfThen::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IfThen::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IfThen::GetClassData() const { return &_class_data_; }


void IfThen::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IfThen*>(&to_msg);
  auto& from = static_cast<const IfThen&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.IfThen)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cond()->::joosc_fuzzer::BoolRvalue::MergeFrom(
          from._internal_cond());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_if_body()->::joosc_fuzzer::StatementSeq::MergeFrom(
          from._internal_if_body());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IfThen::CopyFrom(const IfThen& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.IfThen)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IfThen::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cond()) {
    if (!_impl_.cond_->IsInitialized()) return false;
  }
  if (_internal_has_if_body()) {
    if (!_impl_.if_body_->IsInitialized()) return false;
  }
  return true;
}

void IfThen::InternalSwap(IfThen* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IfThen, _impl_.if_body_)
      + sizeof(IfThen::_impl_.if_body_)
      - PROTOBUF_FIELD_OFFSET(IfThen, _impl_.cond_)>(
          reinterpret_cast<char*>(&_impl_.cond_),
          reinterpret_cast<char*>(&other->_impl_.cond_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IfThen::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[12]);
}

// ===================================================================

class IfElse::_Internal {
 public:
  using HasBits = decltype(std::declval<IfElse>()._impl_._has_bits_);
  static const ::joosc_fuzzer::BoolRvalue& cond(const IfElse* msg);
  static void set_has_cond(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::StatementSeq& if_body(const IfElse* msg);
  static void set_has_if_body(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::joosc_fuzzer::StatementSeq& else_body(const IfElse* msg);
  static void set_has_else_body(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::joosc_fuzzer::BoolRvalue&
IfElse::_Internal::cond(const IfElse* msg) {
  return *msg->_impl_.cond_;
}
const ::joosc_fuzzer::StatementSeq&
IfElse::_Internal::if_body(const IfElse* msg) {
  return *msg->_impl_.if_body_;
}
const ::joosc_fuzzer::StatementSeq&
IfElse::_Internal::else_body(const IfElse* msg) {
  return *msg->_impl_.else_body_;
}
IfElse::IfElse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.IfElse)
}
IfElse::IfElse(const IfElse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IfElse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cond_){nullptr}
    , decltype(_impl_.if_body_){nullptr}
    , decltype(_impl_.else_body_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cond()) {
    _this->_impl_.cond_ = new ::joosc_fuzzer::BoolRvalue(*from._impl_.cond_);
  }
  if (from._internal_has_if_body()) {
    _this->_impl_.if_body_ = new ::joosc_fuzzer::StatementSeq(*from._impl_.if_body_);
  }
  if (from._internal_has_else_body()) {
    _this->_impl_.else_body_ = new ::joosc_fuzzer::StatementSeq(*from._impl_.else_body_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.IfElse)
}

inline void IfElse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cond_){nullptr}
    , decltype(_impl_.if_body_){nullptr}
    , decltype(_impl_.else_body_){nullptr}
  };
}

IfElse::~IfElse() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.IfElse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IfElse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cond_;
  if (this != internal_default_instance()) delete _impl_.if_body_;
  if (this != internal_default_instance()) delete _impl_.else_body_;
}

void IfElse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IfElse::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.IfElse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cond_ != nullptr);
      _impl_.cond_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.if_body_ != nullptr);
      _impl_.if_body_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.else_body_ != nullptr);
      _impl_.else_body_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IfElse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.BoolRvalue cond = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cond(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.StatementSeq if_body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_if_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.StatementSeq else_body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_else_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IfElse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.IfElse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.BoolRvalue cond = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cond(this),
        _Internal::cond(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.StatementSeq if_body = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::if_body(this),
        _Internal::if_body(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.StatementSeq else_body = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::else_body(this),
        _Internal::else_body(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.IfElse)
  return target;
}

size_t IfElse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.IfElse)
  size_t total_size = 0;

  if (_internal_has_cond()) {
    // required .joosc_fuzzer.BoolRvalue cond = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cond_);
  }

  if (_internal_has_if_body()) {
    // required .joosc_fuzzer.StatementSeq if_body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.if_body_);
  }

  if (_internal_has_else_body()) {
    // required .joosc_fuzzer.StatementSeq else_body = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.else_body_);
  }

  return total_size;
}
size_t IfElse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.IfElse)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.BoolRvalue cond = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cond_);

    // required .joosc_fuzzer.StatementSeq if_body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.if_body_);

    // required .joosc_fuzzer.StatementSeq else_body = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.else_body_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IfElse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IfElse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IfElse::GetClassData() const { return &_class_data_; }


void IfElse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IfElse*>(&to_msg);
  auto& from = static_cast<const IfElse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.IfElse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cond()->::joosc_fuzzer::BoolRvalue::MergeFrom(
          from._internal_cond());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_if_body()->::joosc_fuzzer::StatementSeq::MergeFrom(
          from._internal_if_body());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_else_body()->::joosc_fuzzer::StatementSeq::MergeFrom(
          from._internal_else_body());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IfElse::CopyFrom(const IfElse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.IfElse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IfElse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cond()) {
    if (!_impl_.cond_->IsInitialized()) return false;
  }
  if (_internal_has_if_body()) {
    if (!_impl_.if_body_->IsInitialized()) return false;
  }
  if (_internal_has_else_body()) {
    if (!_impl_.else_body_->IsInitialized()) return false;
  }
  return true;
}

void IfElse::InternalSwap(IfElse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IfElse, _impl_.else_body_)
      + sizeof(IfElse::_impl_.else_body_)
      - PROTOBUF_FIELD_OFFSET(IfElse, _impl_.cond_)>(
          reinterpret_cast<char*>(&_impl_.cond_),
          reinterpret_cast<char*>(&other->_impl_.cond_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IfElse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[13]);
}

// ===================================================================

class While::_Internal {
 public:
  using HasBits = decltype(std::declval<While>()._impl_._has_bits_);
  static const ::joosc_fuzzer::BoolRvalue& cond(const While* msg);
  static void set_has_cond(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::StatementSeq& body(const While* msg);
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::joosc_fuzzer::BoolRvalue&
While::_Internal::cond(const While* msg) {
  return *msg->_impl_.cond_;
}
const ::joosc_fuzzer::StatementSeq&
While::_Internal::body(const While* msg) {
  return *msg->_impl_.body_;
}
While::While(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.While)
}
While::While(const While& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  While* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cond_){nullptr}
    , decltype(_impl_.body_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cond()) {
    _this->_impl_.cond_ = new ::joosc_fuzzer::BoolRvalue(*from._impl_.cond_);
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::joosc_fuzzer::StatementSeq(*from._impl_.body_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.While)
}

inline void While::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cond_){nullptr}
    , decltype(_impl_.body_){nullptr}
  };
}

While::~While() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.While)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void While::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cond_;
  if (this != internal_default_instance()) delete _impl_.body_;
}

void While::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void While::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.While)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cond_ != nullptr);
      _impl_.cond_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.body_ != nullptr);
      _impl_.body_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* While::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.BoolRvalue cond = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cond(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.StatementSeq body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* While::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.While)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.BoolRvalue cond = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cond(this),
        _Internal::cond(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.StatementSeq body = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.While)
  return target;
}

size_t While::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.While)
  size_t total_size = 0;

  if (_internal_has_cond()) {
    // required .joosc_fuzzer.BoolRvalue cond = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cond_);
  }

  if (_internal_has_body()) {
    // required .joosc_fuzzer.StatementSeq body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  return total_size;
}
size_t While::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.While)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.BoolRvalue cond = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cond_);

    // required .joosc_fuzzer.StatementSeq body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData While::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    While::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*While::GetClassData() const { return &_class_data_; }


void While::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<While*>(&to_msg);
  auto& from = static_cast<const While&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.While)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cond()->::joosc_fuzzer::BoolRvalue::MergeFrom(
          from._internal_cond());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_body()->::joosc_fuzzer::StatementSeq::MergeFrom(
          from._internal_body());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void While::CopyFrom(const While& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.While)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool While::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cond()) {
    if (!_impl_.cond_->IsInitialized()) return false;
  }
  if (_internal_has_body()) {
    if (!_impl_.body_->IsInitialized()) return false;
  }
  return true;
}

void While::InternalSwap(While* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(While, _impl_.body_)
      + sizeof(While::_impl_.body_)
      - PROTOBUF_FIELD_OFFSET(While, _impl_.cond_)>(
          reinterpret_cast<char*>(&_impl_.cond_),
          reinterpret_cast<char*>(&other->_impl_.cond_));
}

::PROTOBUF_NAMESPACE_ID::Metadata While::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[14]);
}

// ===================================================================

class Statement::_Internal {
 public:
  static const ::joosc_fuzzer::AssignmentStatement& assignment(const Statement* msg);
  static const ::joosc_fuzzer::IfThen& ifthen(const Statement* msg);
  static const ::joosc_fuzzer::IfElse& ifelse(const Statement* msg);
  static const ::joosc_fuzzer::While& while_loop(const Statement* msg);
  static const ::joosc_fuzzer::MethodInvocationStatement& method_call(const Statement* msg);
};

const ::joosc_fuzzer::AssignmentStatement&
Statement::_Internal::assignment(const Statement* msg) {
  return *msg->_impl_.stmt_oneof_.assignment_;
}
const ::joosc_fuzzer::IfThen&
Statement::_Internal::ifthen(const Statement* msg) {
  return *msg->_impl_.stmt_oneof_.ifthen_;
}
const ::joosc_fuzzer::IfElse&
Statement::_Internal::ifelse(const Statement* msg) {
  return *msg->_impl_.stmt_oneof_.ifelse_;
}
const ::joosc_fuzzer::While&
Statement::_Internal::while_loop(const Statement* msg) {
  return *msg->_impl_.stmt_oneof_.while_loop_;
}
const ::joosc_fuzzer::MethodInvocationStatement&
Statement::_Internal::method_call(const Statement* msg) {
  return *msg->_impl_.stmt_oneof_.method_call_;
}
void Statement::set_allocated_assignment(::joosc_fuzzer::AssignmentStatement* assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_stmt_oneof();
  if (assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(assignment);
    if (message_arena != submessage_arena) {
      assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    set_has_assignment();
    _impl_.stmt_oneof_.assignment_ = assignment;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Statement.assignment)
}
void Statement::set_allocated_ifthen(::joosc_fuzzer::IfThen* ifthen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_stmt_oneof();
  if (ifthen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ifthen);
    if (message_arena != submessage_arena) {
      ifthen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ifthen, submessage_arena);
    }
    set_has_ifthen();
    _impl_.stmt_oneof_.ifthen_ = ifthen;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Statement.ifthen)
}
void Statement::set_allocated_ifelse(::joosc_fuzzer::IfElse* ifelse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_stmt_oneof();
  if (ifelse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ifelse);
    if (message_arena != submessage_arena) {
      ifelse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ifelse, submessage_arena);
    }
    set_has_ifelse();
    _impl_.stmt_oneof_.ifelse_ = ifelse;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Statement.ifelse)
}
void Statement::set_allocated_while_loop(::joosc_fuzzer::While* while_loop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_stmt_oneof();
  if (while_loop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(while_loop);
    if (message_arena != submessage_arena) {
      while_loop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, while_loop, submessage_arena);
    }
    set_has_while_loop();
    _impl_.stmt_oneof_.while_loop_ = while_loop;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Statement.while_loop)
}
void Statement::set_allocated_method_call(::joosc_fuzzer::MethodInvocationStatement* method_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_stmt_oneof();
  if (method_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(method_call);
    if (message_arena != submessage_arena) {
      method_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, method_call, submessage_arena);
    }
    set_has_method_call();
    _impl_.stmt_oneof_.method_call_ = method_call;
  }
  // @@protoc_insertion_point(field_set_allocated:joosc_fuzzer.Statement.method_call)
}
Statement::Statement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.Statement)
}
Statement::Statement(const Statement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Statement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stmt_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_stmt_oneof();
  switch (from.stmt_oneof_case()) {
    case kAssignment: {
      _this->_internal_mutable_assignment()->::joosc_fuzzer::AssignmentStatement::MergeFrom(
          from._internal_assignment());
      break;
    }
    case kIfthen: {
      _this->_internal_mutable_ifthen()->::joosc_fuzzer::IfThen::MergeFrom(
          from._internal_ifthen());
      break;
    }
    case kIfelse: {
      _this->_internal_mutable_ifelse()->::joosc_fuzzer::IfElse::MergeFrom(
          from._internal_ifelse());
      break;
    }
    case kWhileLoop: {
      _this->_internal_mutable_while_loop()->::joosc_fuzzer::While::MergeFrom(
          from._internal_while_loop());
      break;
    }
    case kMethodCall: {
      _this->_internal_mutable_method_call()->::joosc_fuzzer::MethodInvocationStatement::MergeFrom(
          from._internal_method_call());
      break;
    }
    case STMT_ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.Statement)
}

inline void Statement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stmt_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_stmt_oneof();
}

Statement::~Statement() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.Statement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Statement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_stmt_oneof()) {
    clear_stmt_oneof();
  }
}

void Statement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Statement::clear_stmt_oneof() {
// @@protoc_insertion_point(one_of_clear_start:joosc_fuzzer.Statement)
  switch (stmt_oneof_case()) {
    case kAssignment: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.stmt_oneof_.assignment_;
      }
      break;
    }
    case kIfthen: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.stmt_oneof_.ifthen_;
      }
      break;
    }
    case kIfelse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.stmt_oneof_.ifelse_;
      }
      break;
    }
    case kWhileLoop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.stmt_oneof_.while_loop_;
      }
      break;
    }
    case kMethodCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.stmt_oneof_.method_call_;
      }
      break;
    }
    case STMT_ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = STMT_ONEOF_NOT_SET;
}


void Statement::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.Statement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_stmt_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Statement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .joosc_fuzzer.AssignmentStatement assignment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_assignment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .joosc_fuzzer.IfThen ifthen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ifthen(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .joosc_fuzzer.IfElse ifelse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ifelse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .joosc_fuzzer.While while_loop = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_while_loop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .joosc_fuzzer.MethodInvocationStatement method_call = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_method_call(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Statement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.Statement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (stmt_oneof_case()) {
    case kAssignment: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::assignment(this),
          _Internal::assignment(this).GetCachedSize(), target, stream);
      break;
    }
    case kIfthen: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::ifthen(this),
          _Internal::ifthen(this).GetCachedSize(), target, stream);
      break;
    }
    case kIfelse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::ifelse(this),
          _Internal::ifelse(this).GetCachedSize(), target, stream);
      break;
    }
    case kWhileLoop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::while_loop(this),
          _Internal::while_loop(this).GetCachedSize(), target, stream);
      break;
    }
    case kMethodCall: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::method_call(this),
          _Internal::method_call(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.Statement)
  return target;
}

size_t Statement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.Statement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (stmt_oneof_case()) {
    // .joosc_fuzzer.AssignmentStatement assignment = 1;
    case kAssignment: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stmt_oneof_.assignment_);
      break;
    }
    // .joosc_fuzzer.IfThen ifthen = 2;
    case kIfthen: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stmt_oneof_.ifthen_);
      break;
    }
    // .joosc_fuzzer.IfElse ifelse = 3;
    case kIfelse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stmt_oneof_.ifelse_);
      break;
    }
    // .joosc_fuzzer.While while_loop = 4;
    case kWhileLoop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stmt_oneof_.while_loop_);
      break;
    }
    // .joosc_fuzzer.MethodInvocationStatement method_call = 5;
    case kMethodCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stmt_oneof_.method_call_);
      break;
    }
    case STMT_ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Statement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Statement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Statement::GetClassData() const { return &_class_data_; }


void Statement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Statement*>(&to_msg);
  auto& from = static_cast<const Statement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.Statement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.stmt_oneof_case()) {
    case kAssignment: {
      _this->_internal_mutable_assignment()->::joosc_fuzzer::AssignmentStatement::MergeFrom(
          from._internal_assignment());
      break;
    }
    case kIfthen: {
      _this->_internal_mutable_ifthen()->::joosc_fuzzer::IfThen::MergeFrom(
          from._internal_ifthen());
      break;
    }
    case kIfelse: {
      _this->_internal_mutable_ifelse()->::joosc_fuzzer::IfElse::MergeFrom(
          from._internal_ifelse());
      break;
    }
    case kWhileLoop: {
      _this->_internal_mutable_while_loop()->::joosc_fuzzer::While::MergeFrom(
          from._internal_while_loop());
      break;
    }
    case kMethodCall: {
      _this->_internal_mutable_method_call()->::joosc_fuzzer::MethodInvocationStatement::MergeFrom(
          from._internal_method_call());
      break;
    }
    case STMT_ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Statement::CopyFrom(const Statement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.Statement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Statement::IsInitialized() const {
  switch (stmt_oneof_case()) {
    case kAssignment: {
      if (_internal_has_assignment()) {
        if (!_impl_.stmt_oneof_.assignment_->IsInitialized()) return false;
      }
      break;
    }
    case kIfthen: {
      if (_internal_has_ifthen()) {
        if (!_impl_.stmt_oneof_.ifthen_->IsInitialized()) return false;
      }
      break;
    }
    case kIfelse: {
      if (_internal_has_ifelse()) {
        if (!_impl_.stmt_oneof_.ifelse_->IsInitialized()) return false;
      }
      break;
    }
    case kWhileLoop: {
      if (_internal_has_while_loop()) {
        if (!_impl_.stmt_oneof_.while_loop_->IsInitialized()) return false;
      }
      break;
    }
    case kMethodCall: {
      if (_internal_has_method_call()) {
        if (!_impl_.stmt_oneof_.method_call_->IsInitialized()) return false;
      }
      break;
    }
    case STMT_ONEOF_NOT_SET: {
      break;
    }
  }
  return true;
}

void Statement::InternalSwap(Statement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stmt_oneof_, other->_impl_.stmt_oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Statement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[15]);
}

// ===================================================================

class StatementSeq::_Internal {
 public:
};

StatementSeq::StatementSeq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.StatementSeq)
}
StatementSeq::StatementSeq(const StatementSeq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatementSeq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.statements_){from._impl_.statements_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.StatementSeq)
}

inline void StatementSeq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.statements_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatementSeq::~StatementSeq() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.StatementSeq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatementSeq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.statements_.~RepeatedPtrField();
}

void StatementSeq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatementSeq::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.StatementSeq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.statements_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatementSeq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .joosc_fuzzer.Statement statements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_statements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatementSeq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.StatementSeq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .joosc_fuzzer.Statement statements = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_statements_size()); i < n; i++) {
    const auto& repfield = this->_internal_statements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.StatementSeq)
  return target;
}

size_t StatementSeq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.StatementSeq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .joosc_fuzzer.Statement statements = 1;
  total_size += 1UL * this->_internal_statements_size();
  for (const auto& msg : this->_impl_.statements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatementSeq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatementSeq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatementSeq::GetClassData() const { return &_class_data_; }


void StatementSeq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatementSeq*>(&to_msg);
  auto& from = static_cast<const StatementSeq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.StatementSeq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.statements_.MergeFrom(from._impl_.statements_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatementSeq::CopyFrom(const StatementSeq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.StatementSeq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatementSeq::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.statements_))
    return false;
  return true;
}

void StatementSeq::InternalSwap(StatementSeq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.statements_.InternalSwap(&other->_impl_.statements_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatementSeq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[16]);
}

// ===================================================================

class StaticField::_Internal {
 public:
  using HasBits = decltype(std::declval<StaticField>()._impl_._has_bits_);
  static const ::joosc_fuzzer::Lvalue& lvalue(const StaticField* msg);
  static void set_has_lvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::joosc_fuzzer::Const& cons(const StaticField* msg);
  static void set_has_cons(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::joosc_fuzzer::Lvalue&
StaticField::_Internal::lvalue(const StaticField* msg) {
  return *msg->_impl_.lvalue_;
}
const ::joosc_fuzzer::Const&
StaticField::_Internal::cons(const StaticField* msg) {
  return *msg->_impl_.cons_;
}
StaticField::StaticField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.StaticField)
}
StaticField::StaticField(const StaticField& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaticField* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lvalue_){nullptr}
    , decltype(_impl_.cons_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_lvalue()) {
    _this->_impl_.lvalue_ = new ::joosc_fuzzer::Lvalue(*from._impl_.lvalue_);
  }
  if (from._internal_has_cons()) {
    _this->_impl_.cons_ = new ::joosc_fuzzer::Const(*from._impl_.cons_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.StaticField)
}

inline void StaticField::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lvalue_){nullptr}
    , decltype(_impl_.cons_){nullptr}
  };
}

StaticField::~StaticField() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.StaticField)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaticField::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.lvalue_;
  if (this != internal_default_instance()) delete _impl_.cons_;
}

void StaticField::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaticField::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.StaticField)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.lvalue_ != nullptr);
      _impl_.lvalue_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cons_ != nullptr);
      _impl_.cons_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaticField::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.Lvalue lvalue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_lvalue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .joosc_fuzzer.Const cons = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cons(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaticField::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.StaticField)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.Lvalue lvalue = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::lvalue(this),
        _Internal::lvalue(this).GetCachedSize(), target, stream);
  }

  // required .joosc_fuzzer.Const cons = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cons(this),
        _Internal::cons(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.StaticField)
  return target;
}

size_t StaticField::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:joosc_fuzzer.StaticField)
  size_t total_size = 0;

  if (_internal_has_lvalue()) {
    // required .joosc_fuzzer.Lvalue lvalue = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lvalue_);
  }

  if (_internal_has_cons()) {
    // required .joosc_fuzzer.Const cons = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cons_);
  }

  return total_size;
}
size_t StaticField::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.StaticField)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .joosc_fuzzer.Lvalue lvalue = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lvalue_);

    // required .joosc_fuzzer.Const cons = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cons_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaticField::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaticField::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaticField::GetClassData() const { return &_class_data_; }


void StaticField::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaticField*>(&to_msg);
  auto& from = static_cast<const StaticField&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.StaticField)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_lvalue()->::joosc_fuzzer::Lvalue::MergeFrom(
          from._internal_lvalue());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cons()->::joosc_fuzzer::Const::MergeFrom(
          from._internal_cons());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaticField::CopyFrom(const StaticField& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.StaticField)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticField::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_lvalue()) {
    if (!_impl_.lvalue_->IsInitialized()) return false;
  }
  if (_internal_has_cons()) {
    if (!_impl_.cons_->IsInitialized()) return false;
  }
  return true;
}

void StaticField::InternalSwap(StaticField* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StaticField, _impl_.cons_)
      + sizeof(StaticField::_impl_.cons_)
      - PROTOBUF_FIELD_OFFSET(StaticField, _impl_.lvalue_)>(
          reinterpret_cast<char*>(&_impl_.lvalue_),
          reinterpret_cast<char*>(&other->_impl_.lvalue_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StaticField::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[17]);
}

// ===================================================================

class Class::_Internal {
 public:
  using HasBits = decltype(std::declval<Class>()._impl_._has_bits_);
  static const ::joosc_fuzzer::StatementSeq& main_body(const Class* msg);
  static void set_has_main_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::joosc_fuzzer::StatementSeq&
Class::_Internal::main_body(const Class* msg) {
  return *msg->_impl_.main_body_;
}
Class::Class(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:joosc_fuzzer.Class)
}
Class::Class(const Class& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Class* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fields_){from._impl_.fields_}
    , decltype(_impl_.methods_){from._impl_.methods_}
    , decltype(_impl_.main_body_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_main_body()) {
    _this->_impl_.main_body_ = new ::joosc_fuzzer::StatementSeq(*from._impl_.main_body_);
  }
  // @@protoc_insertion_point(copy_constructor:joosc_fuzzer.Class)
}

inline void Class::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fields_){arena}
    , decltype(_impl_.methods_){arena}
    , decltype(_impl_.main_body_){nullptr}
  };
}

Class::~Class() {
  // @@protoc_insertion_point(destructor:joosc_fuzzer.Class)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Class::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fields_.~RepeatedPtrField();
  _impl_.methods_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.main_body_;
}

void Class::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Class::Clear() {
// @@protoc_insertion_point(message_clear_start:joosc_fuzzer.Class)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fields_.Clear();
  _impl_.methods_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.main_body_ != nullptr);
    _impl_.main_body_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Class::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .joosc_fuzzer.StatementSeq main_body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_main_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .joosc_fuzzer.StaticField fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .joosc_fuzzer.StatementSeq methods = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_methods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Class::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:joosc_fuzzer.Class)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .joosc_fuzzer.StatementSeq main_body = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::main_body(this),
        _Internal::main_body(this).GetCachedSize(), target, stream);
  }

  // repeated .joosc_fuzzer.StaticField fields = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .joosc_fuzzer.StatementSeq methods = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_methods_size()); i < n; i++) {
    const auto& repfield = this->_internal_methods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:joosc_fuzzer.Class)
  return target;
}

size_t Class::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:joosc_fuzzer.Class)
  size_t total_size = 0;

  // required .joosc_fuzzer.StatementSeq main_body = 1;
  if (_internal_has_main_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.main_body_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .joosc_fuzzer.StaticField fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->_impl_.fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .joosc_fuzzer.StatementSeq methods = 3;
  total_size += 1UL * this->_internal_methods_size();
  for (const auto& msg : this->_impl_.methods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Class::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Class::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Class::GetClassData() const { return &_class_data_; }


void Class::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Class*>(&to_msg);
  auto& from = static_cast<const Class&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:joosc_fuzzer.Class)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
  _this->_impl_.methods_.MergeFrom(from._impl_.methods_);
  if (from._internal_has_main_body()) {
    _this->_internal_mutable_main_body()->::joosc_fuzzer::StatementSeq::MergeFrom(
        from._internal_main_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Class::CopyFrom(const Class& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:joosc_fuzzer.Class)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Class::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.fields_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.methods_))
    return false;
  if (_internal_has_main_body()) {
    if (!_impl_.main_body_->IsInitialized()) return false;
  }
  return true;
}

void Class::InternalSwap(Class* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.fields_.InternalSwap(&other->_impl_.fields_);
  _impl_.methods_.InternalSwap(&other->_impl_.methods_);
  swap(_impl_.main_body_, other->_impl_.main_body_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Class::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_joosc_5fproto_2eproto_getter, &descriptor_table_joosc_5fproto_2eproto_once,
      file_level_metadata_joosc_5fproto_2eproto[18]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace joosc_fuzzer
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::VarRef*
Arena::CreateMaybeMessage< ::joosc_fuzzer::VarRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::VarRef >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::FunctionRef*
Arena::CreateMaybeMessage< ::joosc_fuzzer::FunctionRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::FunctionRef >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::Lvalue*
Arena::CreateMaybeMessage< ::joosc_fuzzer::Lvalue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::Lvalue >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::Rvalue*
Arena::CreateMaybeMessage< ::joosc_fuzzer::Rvalue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::Rvalue >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::Const*
Arena::CreateMaybeMessage< ::joosc_fuzzer::Const >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::Const >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::BinaryOp*
Arena::CreateMaybeMessage< ::joosc_fuzzer::BinaryOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::BinaryOp >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::BoolRvalue*
Arena::CreateMaybeMessage< ::joosc_fuzzer::BoolRvalue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::BoolRvalue >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::BoolToBoolOp*
Arena::CreateMaybeMessage< ::joosc_fuzzer::BoolToBoolOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::BoolToBoolOp >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::IntToBoolOp*
Arena::CreateMaybeMessage< ::joosc_fuzzer::IntToBoolOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::IntToBoolOp >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::AssignmentStatement*
Arena::CreateMaybeMessage< ::joosc_fuzzer::AssignmentStatement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::AssignmentStatement >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::MethodInvocation*
Arena::CreateMaybeMessage< ::joosc_fuzzer::MethodInvocation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::MethodInvocation >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::MethodInvocationStatement*
Arena::CreateMaybeMessage< ::joosc_fuzzer::MethodInvocationStatement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::MethodInvocationStatement >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::IfThen*
Arena::CreateMaybeMessage< ::joosc_fuzzer::IfThen >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::IfThen >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::IfElse*
Arena::CreateMaybeMessage< ::joosc_fuzzer::IfElse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::IfElse >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::While*
Arena::CreateMaybeMessage< ::joosc_fuzzer::While >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::While >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::Statement*
Arena::CreateMaybeMessage< ::joosc_fuzzer::Statement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::Statement >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::StatementSeq*
Arena::CreateMaybeMessage< ::joosc_fuzzer::StatementSeq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::StatementSeq >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::StaticField*
Arena::CreateMaybeMessage< ::joosc_fuzzer::StaticField >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::StaticField >(arena);
}
template<> PROTOBUF_NOINLINE ::joosc_fuzzer::Class*
Arena::CreateMaybeMessage< ::joosc_fuzzer::Class >(Arena* arena) {
  return Arena::CreateMessageInternal< ::joosc_fuzzer::Class >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
